<?xml version="1.0" encoding="utf-8" ?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="15.0">

  <!-- ========================================================================== -->
  <!-- Note: After updating this file, make sure that                             -->
  <!-- %DepotRoot%\xmake\XmakeCommandLine\Microsoft.Build.CommonTypes.xsd         -->
  <!-- is updated to reflect changes.                                             -->
  <!--                                                                            -->
  <!-- To test whether schema changes are OK, copy changed XSD file to            -->
  <!-- %ProgramFiles(x86)%\Microsoft Visual Studio 15.0\Xml\Schemas\1033\MSBuild, -->
  <!-- then open this file in Visual Studio.                                      -->
  <!-- It should not display any schema warnings in error list window.            -->
  <!-- ========================================================================== -->

  <PropertyGroup>
    <MSBuildAllProjects>$(MSBuildAllProjects);$(MSBuildThisFileFullPath)</MSBuildAllProjects>
  </PropertyGroup>

  <PropertyGroup>
    <AppxMSBuildToolsPath Condition="'$(AppxMSBuildToolsPath)' == ''">$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\AppxPackage\</AppxMSBuildToolsPath>
    <AppxMSBuildTaskAssembly Condition="'$(AppxMSBuildTaskAssembly)' == ''">$(AppxMSBuildToolsPath)Microsoft.Build.AppxPackage.dll</AppxMSBuildTaskAssembly>
  </PropertyGroup>

  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreateAppStoreContainer" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreatePriConfigXmlForFullIndex" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreatePriConfigXmlForMainPackageFileMap" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreatePriConfigXmlForSplitting" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.CreatePriFilesForPortableLibraries" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ExpandPayloadDirectories" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ExpandPriContent" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ExtractStoreAssociationInformation" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.FilterItemGroup" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.FilterOutUnusedLanguagesResourceFileMaps" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxPackageRecipe" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateAppxSymbolPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateMappingFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GeneratePriConfigurationFiles" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateProjectArchitecturesFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GenerateProjectPriFile" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetAppxBundlePlatforms" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetDefaultResourceLanguage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetFrameworkSdkPackages" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetPackageArchitecture" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetSdkPropertyValue" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetSdkFileFullPath" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetUnionWinmdPropertyValues" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.GetWindowsDesktopSdkDir" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxContentGroupMap" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.MakeAppxPack" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ParsePlatformSpecificBundleArtifactsLists" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemovePayloadDuplicates" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveDuplicatePriFiles" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.RemoveDuplicateSDKReferences" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.SignAppxPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.UpdateAppxManifestForBundle" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.UpdateMainPackageFileMap" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxManifestItems" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateAppxPackage" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateBundleMapping" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.ValidateStoreManifest" />
  <UsingTask AssemblyFile="$(AppxMSBuildTaskAssembly)" TaskName="Microsoft.Build.AppxPackage.VerifyAppxBundlePlatforms" />

  <!-- Adjust AppxPackage to be true Boolean flag. -->
  <PropertyGroup>
    <AppxPackage Condition="'$(AppxPackage)' != 'true'">false</AppxPackage>
  </PropertyGroup>
  
  <!-- Adjust DeployOptionalPackages to be true Boolean flag. -->
  <PropertyGroup>
    <DeployOptionalPackages Condition="'$(DeployOptionalPackages)' != 'true'">false</DeployOptionalPackages>
  </PropertyGroup>

  <!-- Flags controlling certain features -->
  <PropertyGroup>
    <AppxUseHardlinksIfPossible Condition="'$(AppxUseHardlinksIfPossible)' == ''">true</AppxUseHardlinksIfPossible>
    <AppxUseHardlinksForNugetIfPossible Condition="'$(AppxUseHardlinksForNugetIfPossible)' == ''">false</AppxUseHardlinksForNugetIfPossible>
    <AppxSkipUnchangedFiles Condition="'$(AppxSkipUnchangedFiles)' == ''">true</AppxSkipUnchangedFiles>
    <AppxGeneratePriEnabled Condition="'$(AppxGeneratePriEnabled)' == ''">true</AppxGeneratePriEnabled>
    <AppxGetPackagePropertiesEnabled Condition="'$(AppxGetPackagePropertiesEnabled)' == ''">true</AppxGetPackagePropertiesEnabled>
    <AppxPackageIncludePrivateSymbols Condition="'$(AppxPackageIncludePrivateSymbols)' == ''">false</AppxPackageIncludePrivateSymbols>
    <AppxSymbolPackageEnabled Condition="'$(AppxSymbolPackageEnabled)' == ''">true</AppxSymbolPackageEnabled>
    <AppxTestLayoutEnabled Condition="'$(AppxTestLayoutEnabled)' == ''">true</AppxTestLayoutEnabled>
    <AppxPackageValidationEnabled Condition="'$(AppxPackageValidationEnabled)' == ''">true</AppxPackageValidationEnabled>
    <AppxHarvestWinmdRegistration Condition="'$(AppxHarvestWinmdRegistration)' == ''">true</AppxHarvestWinmdRegistration>
    <AutoIncrementPackageRevision Condition="'$(AutoIncrementPackageRevision)' == ''">true</AutoIncrementPackageRevision>
    <AppxPrependPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == ''">true</AppxPrependPriInitialPath>
    <EnableSigningChecks Condition=" '$(EnableSigningChecks)' == '' ">true</EnableSigningChecks>
    <AppxStrictManifestValidationEnabled Condition="'$(AppxStrictManifestValidationEnabled)' == ''">true</AppxStrictManifestValidationEnabled>
    <AppxFilterOutUnusedLanguagesResourceFileMaps Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == ''">true</AppxFilterOutUnusedLanguagesResourceFileMaps>
    <AppxGeneratePrisForPortableLibrariesEnabled Condition="'$(AppxGeneratePrisForPortableLibrariesEnabled)' == ''">true</AppxGeneratePrisForPortableLibrariesEnabled>
    <AppxGeneratePackageRecipeEnabled Condition="'$(AppxGeneratePackageRecipeEnabled)' == ''">true</AppxGeneratePackageRecipeEnabled>
    <BuildOptionalProjects Condition="'$(BuildOptionalProjects)' == ''" >true</BuildOptionalProjects>
    <PackageOptionalProjectsInIdeBuilds Condition="'$(PackageOptionalProjectsInIdeBuilds)' == ''" >false</PackageOptionalProjectsInIdeBuilds>
  </PropertyGroup>

  <PropertyGroup>
    <_TargetPlatformIsWindowsPhone Condition="'$(TargetPlatformIdentifier)' == 'Windows Phone'">true</_TargetPlatformIsWindowsPhone>
    <_TargetPlatformIsWindowsPhone Condition="'$(TargetPlatformIdentifier)' == 'WindowsPhoneApp'">true</_TargetPlatformIsWindowsPhone>
    <_TargetPlatformIsWindowsPhone Condition="'$(_TargetPlatformIsWindowsPhone)' == ''">false</_TargetPlatformIsWindowsPhone>
  </PropertyGroup>

  <PropertyGroup Condition="'$(AppxPackageSigningEnabled)' == ''">
    <AppxPackageSigningEnabled Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">false</AppxPackageSigningEnabled>
    <AppxPackageSigningEnabled Condition="'$(AppxPackageSigningEnabled)' == ''">true</AppxPackageSigningEnabled>
  </PropertyGroup>

  <!-- Various properties not intended for overriding. -->
  <PropertyGroup>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and  '$(SDKIdentifier)' != ''">6.3.1</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.2'">6.3.0</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.1' and '$(_TargetPlatformIsWindowsPhone)' == 'true'">6.3.1</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == '' and '$(TargetPlatformVersion)' == '8.1' and '$(TargetPlatformIdentifier)' == 'Windows'">6.3.0</AppxOSMinVersion>
    <AppxOSMinVersion Condition="'$(AppxOSMinVersion)' == ''">6.2.1</AppxOSMinVersion>
  </PropertyGroup>

  <PropertyGroup>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == '' and '$(SDKIdentifier)' != ''">6.4.0</AppxOSMaxVersionTested>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == '' and '$(TargetPlatformVersion)' == '8.2'">6.4.0</AppxOSMaxVersionTested>
    <AppxOSMaxVersionTested Condition="'$(AppxOSMaxVersionTested)' == ''">$(AppxOSMinVersion)</AppxOSMaxVersionTested>
  </PropertyGroup>

  <PropertyGroup>
    <NuGetTargetFramework Condition="'$(NuGetTargetFramework)'==''">$(TargetPlatformIdentifier),Version=v$(TargetPlatformMinVersion)</NuGetTargetFramework>
    <RuntimeIdentifiers Condition="'$(RuntimeIdentifiers)'==''">win10-arm;win10-arm-aot;win10-x86;win10-x86-aot;win10-x64;win10-x64-aot</RuntimeIdentifiers>
  </PropertyGroup>

  <PropertyGroup>
    <AppxPackageDirName Condition="'$(AppxPackageDirName)' == ''">AppPackages</AppxPackageDirName>
    <AppxPackageDirWasSpecified Condition="'$(AppxPackageDir)' != ''">true</AppxPackageDirWasSpecified>
    <AppxPackageDirInProjectDir>$(ProjectDir)$(AppxPackageDirName)\</AppxPackageDirInProjectDir>

    <PlatformSpecificBundleArtifactsListDirName Condition="'$(PlatformSpecificBundleArtifactsListDirName)' == ''">BundleArtifacts</PlatformSpecificBundleArtifactsListDirName>
    <PlatformSpecificBundleArtifactsListDirWasSpecified Condition="'$(PlatformSpecificBundleArtifactsListDir)' != ''">true</PlatformSpecificBundleArtifactsListDirWasSpecified>
    <PlatformSpecificBundleArtifactsListDirInProjectDir>$(ProjectDir)$(PlatformSpecificBundleArtifactsListDirName)\</PlatformSpecificBundleArtifactsListDirInProjectDir>
    <PlatformSpecificUploadBundleArtifactsListDirInProjectDir>$(ProjectDir)$(PlatformSpecificBundleArtifactsListDirName)Upload\</PlatformSpecificUploadBundleArtifactsListDirInProjectDir>
  </PropertyGroup>

  <!-- Various overridable properties. -->
  <PropertyGroup>
    <AppxPackageDir Condition="'$(AppxPackageDir)' == '' and '$(OutDirWasSpecified)' == 'true'">$(OutDir)$(AppxPackageDirName)\</AppxPackageDir>
    <AppxPackageDir Condition="'$(AppxPackageDir)' == ''">$(AppxPackageDirInProjectDir)</AppxPackageDir>
    <AppxManifestFileName Condition="'$(AppxManifestFileName)' == ''">AppxManifest.xml</AppxManifestFileName>
    <AppxBundleManifestFileName Condition="'$(AppxBundleManifestFileName)' == ''">AppxBundleManifest.xml</AppxBundleManifestFileName>
    <AppxPackageArtifactsDir Condition="'$(AppxPackageArtifactsDir)' == ''"></AppxPackageArtifactsDir>
    <AppxUploadPackageArtifactsDir Condition="'$(AppxUploadPackageArtifactsDir)' == ''">Upload\</AppxUploadPackageArtifactsDir>
    <ExternalPackagesDir Condition="'$(ExternalPackagesDir)' == ''">ExternalPackages\</ExternalPackagesDir>
    <FinalAppxManifestName Condition="'$(FinalAppxManifestName)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(AppxManifestFileName)</FinalAppxManifestName>
    <FinalAppxUploadManifestName Condition="'$(FinalAppxUploadManifestName)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxManifestFileName)</FinalAppxUploadManifestName>
    <FinalAppxBundleManifestName Condition="'$(FinalAppxBundleManifestName)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)\AppxMetadata\$(AppxBundleManifestFileName)</FinalAppxBundleManifestName>
    <AppxValidateAppxManifest Condition="'$(AppxValidateAppxManifest)' == ''">true</AppxValidateAppxManifest>
    <AppxValidateAppxManifest Condition="'$(AppxValidateAppxManifest)' != 'true'">false</AppxValidateAppxManifest>
    <StoreManifestName Condition="'$(StoreManifestName)' == ''">StoreManifest.xml</StoreManifestName>
    <!-- AppxValidateStoreManifest isn't defined here, because the default depends on the TargetPlatform/Version -->
    <MakePriExeFullPath Condition="'$(MakePriExeFullPath)' == ''"></MakePriExeFullPath>
    <MakeAppxExeFullPath Condition="'$(MakeAppxExeFullPath)' == ''"></MakeAppxExeFullPath>
    <SignAppxPackageExeFullPath Condition="'$(SignAppxPackageExeFullPath)' == ''"></SignAppxPackageExeFullPath>
    <ResgenToolPath Condition="'$(ResgenToolPath)' == ''">$(TargetFrameworkSDKToolsDirectory)</ResgenToolPath>
    <PdbCopyExeFullPath Condition="'$(PdbCopyExeFullPath)' == ''">$(AppxMSBuildToolsPath)PDBCopy.exe</PdbCopyExeFullPath>
    <PdbCmfx64ExeFullPath Condition="'$(PdbCmfx64ExeFullPath)' == ''">$(VC_ExecutablePath_x64_x64)\mspdbcmf.exe</PdbCmfx64ExeFullPath>
    <PdbCmfx86ExeFullPath Condition="'$(PdbCmfx86ExeFullPath)' == ''">$(VC_ExecutablePath_x86_x86)\mspdbcmf.exe</PdbCmfx86ExeFullPath>
    <AppxSymbolStrippedDir Condition="'$(AppxSymbolStrippedDir)' == ''">$(IntermediateOutputPath)Stripped</AppxSymbolStrippedDir>
    <AppxUploadSymbolStrippedDir Condition="'$(AppxUploadSymbolStrippedDir)' == ''">$(IntermediateOutputPath)Upload.Stripped</AppxUploadSymbolStrippedDir>
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' != 'true'"></AppxPriInitialPath>
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == 'true' and '$(AppxPackage)' == 'true' and '$(AppxPriInitialPath)' == ''"></AppxPriInitialPath>
    <AppxPriInitialPath Condition="'$(AppxPrependPriInitialPath)' == 'true' and '$(AppxPackage)' != 'true' and '$(AppxPriInitialPath)' == ''">$(TargetName)</AppxPriInitialPath>
    <ProjectPriFileName Condition="'$(AppxPackage)' == 'true' and '$(ProjectPriFileName)' == ''">resources.pri</ProjectPriFileName>
    <ProjectPriFileName Condition="'$(AppxPackage)' != 'true' and '$(ProjectPriFileName)' == ''">$(AppxPriInitialPath).pri</ProjectPriFileName>
    <ProjectPriFullPath Condition="'$(ProjectPriFullPath)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectPriFileName)</ProjectPriFullPath>
    <ProjectPriUploadFullPath Condition="'$(ProjectPriUploadFullPath)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectPriFileName)</ProjectPriUploadFullPath>
    <AppxPackageRecipe Condition="'$(AppxPackageRecipe)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectName).build.appxrecipe</AppxPackageRecipe>
    <AppxUploadPackageRecipe Condition="'$(AppxUploadPackageRecipe)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectName).build.appxrecipe</AppxUploadPackageRecipe>
    <FinalAppxPackageRecipe Condition="'$(FinalAppxPackageRecipe)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)$(ProjectName).appxrecipe</FinalAppxPackageRecipe>
    <FinalAppxUploadPackageRecipe Condition="'$(FinalAppxUploadPackageRecipe)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(ProjectName).appxrecipe</FinalAppxUploadPackageRecipe>
    <AllowLocalNetworkLoopback Condition="'$(AllowLocalNetworkLoopback)' == ''">true</AllowLocalNetworkLoopback>
    <AppxDefaultHashAlgorithmId Condition="'$(AppxDefaultHashAlgorithmId)' == ''">sha256</AppxDefaultHashAlgorithmId>
    <AppxPackageFileMap Condition="'$(AppxPackageFileMap)' == ''">$(IntermediateOutputPath)package.map.txt</AppxPackageFileMap>
    <AppxUploadPackageFileMap Condition="'$(AppxUploadPackageFileMap)' == ''">$(IntermediateOutputPath)upload.package.map.txt</AppxUploadPackageFileMap>
    <LayoutDir Condition="'$(LayoutDir)'==''">$(TargetDir)AppX</LayoutDir>
    <ManagedWinmdInprocImplementation Condition="'$(ManagedWinmdInprocImplementation)' == ''">CLRHost.dll</ManagedWinmdInprocImplementation>
    <UseIncrementalAppxRegistration Condition="'$(UseIncrementalAppxRegistration)' == ''">true</UseIncrementalAppxRegistration>
    <AppxPackagingInfoFile Condition="'$(AppxPackagingInfoFile)' == ''">$(IntermediateOutputPath)_pkginfo.txt</AppxPackagingInfoFile>
    <AppxUploadPackagingInfoFile Condition="'$(AppxUploadPackagingInfoFile)' == ''">$(IntermediateUploadOutputPath)_pkginfo.txt</AppxUploadPackagingInfoFile>
    <AppxOSMinVersionReplaceManifestVersion Condition="'$(AppxOSMinVersionReplaceManifestVersion)' == ''">true</AppxOSMinVersionReplaceManifestVersion>
    <AppxOSMaxVersionTestedReplaceManifestVersion Condition="'$(AppxOSMaxVersionTestedReplaceManifestVersion)' == ''">true</AppxOSMaxVersionTestedReplaceManifestVersion>
    <PackagingFileWritesLogPath Condition="'$(PackagingFileWritesLogPath)' == ''">$(IntermediateOutputPath)PackagingFileWrites.log</PackagingFileWritesLogPath>
    <PackagingDirectoryWritesLogPath Condition="'$(PackagingDirectoryWritesLogPath)' == ''">$(IntermediateOutputPath)PackagingDirectoryWrites.log</PackagingDirectoryWritesLogPath>
    <AppxCopyLocalFilesOutputGroupIncludeXmlFiles Condition="'$(AppxCopyLocalFilesOutputGroupIncludeXmlFiles)' != 'true'">false</AppxCopyLocalFilesOutputGroupIncludeXmlFiles>
    <AppxPriConfigXmlPackagingSnippetPath Condition="'$(AppxPriConfigXmlPackagingSnippetPath)' == ''"></AppxPriConfigXmlPackagingSnippetPath>
    <AppxPriConfigXmlDefaultSnippetPath Condition="'$(AppxPriConfigXmlDefaultSnippetPath)' == ''"></AppxPriConfigXmlDefaultSnippetPath>
    <TargetPlatformSdkRootOverride Condition="'$(TargetPlatformSdkRootOverride)' == ''"></TargetPlatformSdkRootOverride>
    <TargetPlatformResourceVersion Condition="'$(TargetPlatformResourceVersion)' == ''">$(TargetPlatformVersion)</TargetPlatformResourceVersion>
    <AppxMappingFileDir Condition="'$(AppxMappingFileDir)' == ''">$(TargetDir)$(AppxPackageArtifactsDir)</AppxMappingFileDir>
    <AppxUploadMappingFileDir Condition="'$(AppxUploadMappingFileDir)' == ''">$(TargetDir)$(AppxUploadPackageArtifactsDir)</AppxUploadMappingFileDir>

    <WinMetadataDir Condition="'$(WinMetadataDir)' == ''">WinMetadata</WinMetadataDir>
    <EntryPointDir Condition="'$(EntryPointDir)' == ''">entrypoint</EntryPointDir>

    <AppxManifestTargetPath Condition="'$(AppxManifestTargetPath)' == ''">$(AppxManifestFileName)</AppxManifestTargetPath>
    <DeploymentRecipeTargetPath Condition="'$(DeploymentRecipeTargetPath)' == ''">vs.appxrecipe</DeploymentRecipeTargetPath>

    <AppxPackageExtension>.appx</AppxPackageExtension>
    <AppxPackageEncryptedExtension>.eappx</AppxPackageEncryptedExtension>
    <AppxSymbolPackageExtension>.appxsym</AppxSymbolPackageExtension>
    <AppxBundleExtension>.appxbundle</AppxBundleExtension>
    <AppxBundleEncryptedExtension>.eappxbundle</AppxBundleEncryptedExtension>
    <AppxStoreContainerExtension>.appxupload</AppxStoreContainerExtension>
    <AppxIntermediateExtension>.intermediate</AppxIntermediateExtension>

    <AppxBundle Condition="'$(TargetPlatformVersion)' == '8.0'">Never</AppxBundle>
    <AppxBundleDefaultValueUsed Condition="'$(AppxBundle)' == ''">true</AppxBundleDefaultValueUsed>
    <AppxBundleDefaultValueUsed Condition="'$(AppxBundleDefaultValueUsed)' == ''">false</AppxBundleDefaultValueUsed>
    <AppxBundle Condition="'$(AppxBundle)' == ''">Auto</AppxBundle>
    <AppxBundlePlatforms Condition="'$(AppxBundlePlatforms)' == ''"></AppxBundlePlatforms>
    <AppxBundleProducingPlatform Condition="'$(AppxBundleProducingPlatform)' == ''"></AppxBundleProducingPlatform>
    <AppxBundleResourcePacksProducingPlatform Condition="'$(AppxBundleResourcePacksProducingPlatform)' == ''"></AppxBundleResourcePacksProducingPlatform>
    <AppxLayoutFolderName Condition="'$(AppxLayoutFolderName)' == ''">PackageLayout</AppxLayoutFolderName>
    <IntermediateUploadOutputPath Condition="'$(IntermediateUploadOutputPath)' == ''">$(IntermediateOutputPath)Upload\</IntermediateUploadOutputPath>
    <AppxLayoutDir Condition="'$(AppxLayoutDir)' == ''">$(IntermediateOutputPath)$(AppxLayoutFolderName)\</AppxLayoutDir>
    <AppxUploadLayoutFolderName Condition="'$(AppxUploadLayoutFolderName)' == ''">PackageUploadLayout</AppxUploadLayoutFolderName>
    <AppxUploadLayoutDir Condition="'$(AppxUploadLayoutDir)' == ''">$(IntermediateOutputPath)$(AppxUploadLayoutFolderName)</AppxUploadLayoutDir>
    <AppxBundleSplitResourcesPriPrefix Condition="'$(AppxBundleSplitResourcesPriPrefix)' == ''">split</AppxBundleSplitResourcesPriPrefix>
    <AppxBundlePriConfigXmlForSplittingFileName Condition="'$(AppxBundlePriConfigXmlForSplittingFileName)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).priconfig.xml</AppxBundlePriConfigXmlForSplittingFileName>
    <AppxUploadBundlePriConfigXmlForSplittingFileName Condition="'$(AppxUploadBundlePriConfigXmlForSplittingFileName)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).priconfig.xml</AppxUploadBundlePriConfigXmlForSplittingFileName>
    <AppxBundleAutoResourcePackageQualifiers Condition="'$(AppxBundleAutoResourcePackageQualifiers)' == ''">Language|Scale|DXFeatureLevel</AppxBundleAutoResourcePackageQualifiers>
    <AppxBundleSplitResourcesPriPath Condition="'$(AppxBundleSplitResourcesPriPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).pri</AppxBundleSplitResourcesPriPath>
    <AppxBundleSplitResourcesGeneratedFilesListPath Condition="'$(AppxBundleSplitResourcesGeneratedFilesListPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).generatedFiles.txt</AppxBundleSplitResourcesGeneratedFilesListPath>
    <AppxBundleSplitResourcesQualifiersPath Condition="'$(AppxBundleSplitResourcesQualifiersPath)' == ''">$(IntermediateOutputPath)$(AppxBundleSplitResourcesPriPrefix).qualifiers.txt</AppxBundleSplitResourcesQualifiersPath>
    <AppxUploadBundleSplitResourcesPriPath Condition="'$(AppxUploadBundleSplitResourcesPriPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).pri</AppxUploadBundleSplitResourcesPriPath>
    <AppxUploadBundleSplitResourcesGeneratedFilesListPath Condition="'$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).generatedFiles.txt</AppxUploadBundleSplitResourcesGeneratedFilesListPath>
    <AppxUploadBundleSplitResourcesQualifiersPath Condition="'$(AppxUploadBundleSplitResourcesQualifiersPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleSplitResourcesPriPrefix).qualifiers.txt</AppxUploadBundleSplitResourcesQualifiersPath>
    <AppxBundlePriConfigXmlForMainPackageFileMapFileName Condition="'$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)' == ''">$(IntermediateOutputPath)filemap.priconfig.xml</AppxBundlePriConfigXmlForMainPackageFileMapFileName>
    <AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName Condition="'$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)' == ''">$(IntermediateUploadOutputPath)filemap.priconfig.xml</AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName>
    <AppxBundleMainPackageFileMapIntermediatePrefix Condition="'$(AppxBundleMainPackageFileMapIntermediatePrefix)' == ''">filemap</AppxBundleMainPackageFileMapIntermediatePrefix>
    <AppxBundleMainPackageFileMapSuffix Condition="'$(AppxBundleMainPackageFileMapSuffix)' == ''">.map</AppxBundleMainPackageFileMapSuffix>
    <AppxBundleMainPackageFileMapIntermediatePath Condition="'$(AppxBundleMainPackageFileMapIntermediatePath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxBundleMainPackageFileMapIntermediatePath>
    <AppxBundleMainPackageFileMapIntermediatePriPath Condition="'$(AppxBundleMainPackageFileMapIntermediatePriPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).pri</AppxBundleMainPackageFileMapIntermediatePriPath>
    <AppxBundleMainPackageFileMapGeneratedFilesListPath Condition="'$(AppxBundleMainPackageFileMapGeneratedFilesListPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).generatedFiles.txt</AppxBundleMainPackageFileMapGeneratedFilesListPath>
    <AppxBundleMainPackageFileMapPrefix Condition="'$(AppxBundleMainPackageFileMapPrefix)' == ''">main</AppxBundleMainPackageFileMapPrefix>
    <AppxBundleMainPackageFileMapPath Condition="'$(AppxBundleMainPackageFileMapPath)' == ''">$(IntermediateOutputPath)$(AppxBundleMainPackageFileMapPrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxBundleMainPackageFileMapPath>
    <AppxUploadBundleMainPackageFileMapIntermediatePath Condition="'$(AppxUploadBundleMainPackageFileMapIntermediatePath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxUploadBundleMainPackageFileMapIntermediatePath>
    <AppxUploadBundleMainPackageFileMapIntermediatePriPath Condition="'$(AppxUploadBundleMainPackageFileMapIntermediatePriPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).pri</AppxUploadBundleMainPackageFileMapIntermediatePriPath>
    <AppxUploadBundleMainPackageFileMapGeneratedFilesListPath Condition="'$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapIntermediatePrefix).generatedFiles.txt</AppxUploadBundleMainPackageFileMapGeneratedFilesListPath>
    <AppxUploadBundleMainPackageFileMapPath Condition="'$(AppxUploadBundleMainPackageFileMapPath)' == ''">$(IntermediateUploadOutputPath)$(AppxBundleMainPackageFileMapPrefix)$(AppxBundleMainPackageFileMapSuffix).txt</AppxUploadBundleMainPackageFileMapPath>
    <AppxBundleFolderSuffix Condition="'$(AppxBundleFolderSuffix)' == ''">_Bundle</AppxBundleFolderSuffix>

    <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDir)' == '' and '$(OutDirWasSpecified)' == 'true'">$(OutDir)$(PlatformSpecificBundleArtifactsListDirName)\</PlatformSpecificBundleArtifactsListDir>
    <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDir)' == ''">$(PlatformSpecificBundleArtifactsListDirInProjectDir)</PlatformSpecificBundleArtifactsListDir>

    <!-- Continue to honor the UapDefaultAssetScale property for compat reasons.  But going forward advertise the property "AppxDefaultResourceQualifierUAP_{ValueName} as the desired override property. -->
    <UapDefaultAssetScale Condition="'$(UapDefaultAssetScale)' == ''">200</UapDefaultAssetScale>
    <AppxDefaultResourceQualifierUAP_Scale Condition="'$(AppxDefaultResourceQualifierUAP_Scale)' == ''">$(UapDefaultAssetScale)</AppxDefaultResourceQualifierUAP_Scale>

    <AppxDefaultResourceQualifierUAP_Language Condition="'$(AppxDefaultResourceQualifierUAP_Language)' == ''">{DefaultResourceLanguage}</AppxDefaultResourceQualifierUAP_Language>
    <AppxDefaultResourceQualifierUAP_Contrast Condition="'$(AppxDefaultResourceQualifierUAP_Contrast)' == ''">standard</AppxDefaultResourceQualifierUAP_Contrast>
    <AppxDefaultResourceQualifierUAP_HomeRegion Condition="'$(AppxDefaultResourceQualifierUAP_HomeRegion)' == ''">001</AppxDefaultResourceQualifierUAP_HomeRegion>
    <AppxDefaultResourceQualifierUAP_TargetSize Condition="'$(AppxDefaultResourceQualifierUAP_TargetSize)' == ''">256</AppxDefaultResourceQualifierUAP_TargetSize>
    <AppxDefaultResourceQualifierUAP_LayoutDirection Condition="'$(AppxDefaultResourceQualifierUAP_LayoutDirection)' == ''">LTR</AppxDefaultResourceQualifierUAP_LayoutDirection>
    <AppxDefaultResourceQualifierUAP_DxFeatureLevel Condition="'$(AppxDefaultResourceQualifierUAP_DxFeatureLevel)' == ''">DX9</AppxDefaultResourceQualifierUAP_DxFeatureLevel>
    <AppxDefaultResourceQualifierUAP_Platform Condition="'$(AppxDefaultResourceQualifierUAP_Platform)' == ''">UAP</AppxDefaultResourceQualifierUAP_Platform>

    <DisableAppxManifestItemPackageContentValidation Condition="'$(DisableAppxManifestItemPackageContentValidation)' == ''">false</DisableAppxManifestItemPackageContentValidation>
    <RemoveNonLayoutFiles Condition="'$(RemoveNonLayoutFiles)' == ''">true</RemoveNonLayoutFiles>
    <IncludeLayoutFilesInPackage Condition="'$(IncludeLayoutFilesInPackage)' == ''">false</IncludeLayoutFilesInPackage>
  </PropertyGroup>

  <PropertyGroup>
    <AppxDefaultResourceQualifiers_Windows_80>Language={DefaultResourceLanguage}</AppxDefaultResourceQualifiers_Windows_80>
    <AppxDefaultResourceQualifiers_Windows_81>Language={DefaultResourceLanguage}|Contrast=standard|Scale=100|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Configuration=|AlternateForm=</AppxDefaultResourceQualifiers_Windows_81>
    <AppxDefaultResourceQualifiers_Windows_Phone>Language={DefaultResourceLanguage}|Contrast=standard|Scale=240|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Theme=Dark|AlternateForm=</AppxDefaultResourceQualifiers_Windows_Phone>
    <AppxDefaultResourceQualifiers_Windows_82>Language={DefaultResourceLanguage}|Contrast=standard|Scale=100|HomeRegion=001|TargetSize=256|LayoutDirection=LTR|DXFeatureLevel=DX9|Configuration=|AlternateForm=</AppxDefaultResourceQualifiers_Windows_82>
    <AppxDefaultResourceQualifiers_UAP>Language=$(AppxDefaultResourceQualifierUAP_Language)|Contrast=$(AppxDefaultResourceQualifierUAP_Contrast)|Scale=$(AppxDefaultResourceQualifierUAP_Scale)|HomeRegion=$(AppxDefaultResourceQualifierUAP_HomeRegion)|TargetSize=$(AppxDefaultResourceQualifierUAP_TargetSize)|LayoutDirection=$(AppxDefaultResourceQualifierUAP_LayoutDirection)|DXFeatureLevel=$(AppxDefaultResourceQualifierUAP_DxFeatureLevel)|Configuration=$(AppxDefaultResourceQualifierUAP_Configuration)|AlternateForm=$(AppxDefaultResourceQualifierUAP_AlternateForm)|Platform=$(AppxDefaultResourceQualifierUAP_Platform)</AppxDefaultResourceQualifiers_UAP>
  </PropertyGroup>

  <PropertyGroup Condition="'$(AppxDefaultResourceQualifiers)' == ''">
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.0'">$(AppxDefaultResourceQualifiers_Windows_80)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.1'">$(AppxDefaultResourceQualifiers_Windows_81)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.2'">$(AppxDefaultResourceQualifiers_Windows_82)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(TargetPlatformIdentifier)' == 'Portable'">$(AppxDefaultResourceQualifiers_Windows_81)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(SDKIdentifier)' != ''">$(AppxDefaultResourceQualifiers_UAP)</AppxDefaultResourceQualifiers>
    <AppxDefaultResourceQualifiers Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">$(AppxDefaultResourceQualifiers_Windows_Phone)</AppxDefaultResourceQualifiers>
  </PropertyGroup>

  <PropertyGroup Condition="'$(AppxOmitSchemaFromResourcePacks)' == ''">
    <AppxOmitSchemaFromResourcePacks Condition="'$(TargetPlatformIdentifier)' == 'UAP'">true</AppxOmitSchemaFromResourcePacks>
    <AppxOmitSchemaFromResourcePacks Condition="'$(TargetPlatformIdentifier)' != 'UAP'">false</AppxOmitSchemaFromResourcePacks>
  </PropertyGroup>

  <!-- If value is still not set, it is a platform yet unknown to us. -->
  <!-- Default to same value as for latest version of Windows.        -->
  <PropertyGroup Condition="'$(AppxDefaultResourceQualifiers)' == ''">
    <AppxDefaultResourceQualifiers>$(AppxDefaultResourceQualifiers_UAP)</AppxDefaultResourceQualifiers>
  </PropertyGroup>

  <ItemGroup>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha256">
      <Id>SHA256</Id>
    </AppxHashUri>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha384">
      <Id>SHA384</Id>
    </AppxHashUri>
    <AppxHashUri Include="http://www.w3.org/2001/04/xmlenc#sha512">
      <Id>SHA512</Id>
    </AppxHashUri>
  </ItemGroup>

  <PropertyGroup>
    <StandardBuildPipeline>1.0</StandardBuildPipeline>
    <UapBuildPipeline>2.0</UapBuildPipeline>
    <AppxPackagePipelineVersion>$(StandardBuildPipeline)</AppxPackagePipelineVersion>
    <AppxPackagePipelineVersion Condition="'$(SDKIdentifier)' != ''">$(UapBuildPipeline)</AppxPackagePipelineVersion>
  </PropertyGroup>

  <PropertyGroup>
    <SdkIsRS1OrLater>False</SdkIsRS1OrLater>
    <SdkIsRS1OrLater Condition="'$(TargetPlatformVersion)' &gt;= '10.0.11000.0'">True</SdkIsRS1OrLater>
  </PropertyGroup>

  <PropertyGroup>
    <AppxPackageEncryptionEnabled Condition="'$(AppxPackageEncryptionEnabled)' == '' or '$(SdkIsRS1OrLater)' != 'True'">False</AppxPackageEncryptionEnabled>
  </PropertyGroup>

  <PropertyGroup>
    <UapAppxPackageBuildModeStoreUpload>StoreUpload</UapAppxPackageBuildModeStoreUpload>
    <UapAppxPackageBuildModeSideloadOnly>SideloadOnly</UapAppxPackageBuildModeSideloadOnly>
    <UapAppxPackageBuildModeCI>CI</UapAppxPackageBuildModeCI>
  </PropertyGroup>

  <PropertyGroup>
    <UapAppxPackageBuildModeIsValid>false</UapAppxPackageBuildModeIsValid>
  </PropertyGroup>

  <!--If UapAppxPackageBuildMode is set to UapAppxPackageBuildModeStoreUpload, prep all the appropriate flags to produce an appxupload & sideload package-->
  <PropertyGroup Condition="'$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeStoreUpload)' and
                            '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and
                            '$(UseDotNetNativeToolchain)' != 'false' and
                            '$(Configuration)' != 'Debug'">
    <UapAppxPackageBuildModeIsValid>true</UapAppxPackageBuildModeIsValid>
    <BuildAppxUploadPackageForUap>true</BuildAppxUploadPackageForUap>
    <BuildAppxSideloadPackageForUap>true</BuildAppxSideloadPackageForUap>
    <AppxPackageIsForStore>true</AppxPackageIsForStore>
  </PropertyGroup>

  <!--If UapAppxPackageBuildMode is set to UapAppxPackageBuildModeSideloadOnly, prep all the appropriate flags to produce an appx sideload package-->
  <PropertyGroup Condition="'$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeSideloadOnly)' and
                            '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <UapAppxPackageBuildModeIsValid>true</UapAppxPackageBuildModeIsValid>
    <BuildAppxUploadPackageForUap>false</BuildAppxUploadPackageForUap>
    <BuildAppxSideloadPackageForUap>true</BuildAppxSideloadPackageForUap>
    <AppxPackageIsForStore>false</AppxPackageIsForStore>
  </PropertyGroup>

  <!--If UapAppxPackageBuildMode is set to UapAppxPackageBuildModeCI, prep all the appropriate flags to produce an appxupload package for continuous integration-->
  <PropertyGroup Condition="'$(UapAppxPackageBuildMode)' == '$(UapAppxPackageBuildModeCI)' and
                            '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <UapAppxPackageBuildModeIsValid>true</UapAppxPackageBuildModeIsValid>

    <BuildAppxUploadPackageForUap>false</BuildAppxUploadPackageForUap>
    <BuildAppxUploadPackageForUap Condition="'$(UseDotNetNativeToolchain)' != 'false' and '$(Configuration)' != 'Debug'">true</BuildAppxUploadPackageForUap>

    <AppxPackageIsForStore>false</AppxPackageIsForStore>
    <AppxPackageIsForStore Condition="'$(UseDotNetNativeToolchain)' != 'false' and '$(Configuration)' != 'Debug'">true</AppxPackageIsForStore>

    <BuildAppxSideloadPackageForUap>false</BuildAppxSideloadPackageForUap>
  </PropertyGroup>

  <!-- Combined checks to see if we should run the store-publishing steps added for the UAP flow. -->
  <PropertyGroup>
    <BuildAppxUploadPackageForUap Condition="'$(BuildAppxUploadPackageForUap)' == '' and
                                             '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and
                                             '$(UseDotNetNativeToolchain)' != 'false' and
                                             '$(Configuration)' != 'Debug' and
                                             '$(AppxPackageIsForStore)' == 'true'">true</BuildAppxUploadPackageForUap>
    <BuildAppxUploadPackageForUap Condition="'$(BuildAppxUploadPackageForUap)' == ''">false</BuildAppxUploadPackageForUap>
  </PropertyGroup>

  <!-- Combined checks to see if we should run the sideload steps added -->
  <PropertyGroup>
    <BuildAppxSideloadPackageForUap Condition="'$(BuildAppxSideloadPackageForUap)' == '' and
                                             '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">true</BuildAppxSideloadPackageForUap>
    <BuildAppxSideloadPackageForUap Condition="'$(BuildAppxSideloadPackageForUap)' == ''">false</BuildAppxSideloadPackageForUap>
  </PropertyGroup>

  <!-- If packaging for the store, force package encryption to be skipped -->
  <PropertyGroup>
    <AppxPackageEncryptionEnabled Condition="'$(AppxPackageIsForStore)' == 'true'">false</AppxPackageEncryptionEnabled>
  </PropertyGroup>

  <!-- Calculate whether to allow debug framework references in app manifest.    -->
  <!-- Allow overriding this from command line or user config file if necessary. -->

  <PropertyGroup Condition="'$(AppxPackageAllowDebugFrameworkReferencesInManifest)' == ''">

    <!-- Allow debug framework references when not packaging for the store. -->
    <AppxPackageAllowDebugFrameworkReferencesInManifest Condition="'$(AppxPackageIsForStore)' != 'true'">true</AppxPackageAllowDebugFrameworkReferencesInManifest>
    <AppxPackageAllowDebugFrameworkReferencesInManifest Condition="'$(AppxPackageAllowDebugFrameworkReferencesInManifest)' == ''">false</AppxPackageAllowDebugFrameworkReferencesInManifest>

  </PropertyGroup>

  <!--
        When building on the command line or in TFS (determined by looking at the $(BuildingInsideVisualStudio) property), if build is invoked on an
        app package-producing project, the package for the project will be produced as part of building the project without specifying any additional
        flags or targets. This is control by an MSBuild property named GenerateAppxPackageOnBuild which is set to true by default.
    
        If $(BuildingInsideVisualStudio) = false and $(GenerateAppxPackageOnBuild) = true, then build will also produce a package.
    -->
  <PropertyGroup>
    <GenerateAppxPackageOnBuild Condition="'$(AppxPackage)' == 'true' and '$(GenerateAppxPackageOnBuild)' == '' and '$(BuildingInsideVisualStudio)' != 'true'">true</GenerateAppxPackageOnBuild>
  </PropertyGroup>

  <PropertyGroup>
    <UseSubFolderForOutputDirDuringMultiPlatformBuild Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">true</UseSubFolderForOutputDirDuringMultiPlatformBuild>
    <UseSubFolderForOutputDirDuringMultiPlatformBuild Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == ''">false</UseSubFolderForOutputDirDuringMultiPlatformBuild>
  </PropertyGroup>

  <!-- Names of the files which are allways present on the machine and should not be part of the payload. -->
  <ItemGroup>
    <AppxSystemBinary Include="CLRHost.dll" />
    <AppxSystemBinary Include="CLRHost.exe" />
    <AppxSystemBinary Include="WWAHost.exe" />
  </ItemGroup>

  <!-- Reserved file names which cannot appear in the package. -->
  <ItemGroup>
    <AppxReservedFileName Include="$(AppxManifestFileName)" />
    <AppxReservedFileName Include="AppxBlockMap.xml" />
    <AppxReservedFileName Include="[Content_Types].xml" />
    <AppxReservedFileName Include="AppxSignature.p7x" />
    <AppxReservedFileName Include="Microsoft.System.Package.Metadata" />
  </ItemGroup>

  <!-- XPath queries used to extract file names from the manifest. -->
  <ItemGroup>
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:InProcessServer/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:OutOfProcessServer/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:ProxyStub/m:Path" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:GameExplorer/@GameDefinitionContainer" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Extensions/m:Extension/m:Certificates/m:Certificate/@Content" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Applications/m:Application/@Executable" />
    <AppxManifestFileNameQuery Include="./m:Package/m:Applications/m:Application/m:Extensions/m:Extension/@Executable" />
  </ItemGroup>

  <!-- XPath queries used to extract image file names from the manifest. -->
  <ItemGroup Condition="'$(AppxPackagePipelineVersion)' != '$(UapBuildPipeline)'">
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Properties/m:Logo">
      <DescriptionID>StoreLogo</DescriptionID>
      <ExpectedScaleDimensions>100:50x50;140:70x70;180:90x90;240:120x120</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m:VisualElements/@Logo">
      <DescriptionID>TileLogo</DescriptionID>
      <ExpectedScaleDimensions>80:120x120;100:150x150;140:210x210;180:270x270</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m:VisualElements/@SmallLogo">
      <DescriptionID>SmallLogo</DescriptionID>
      <ExpectedScaleDimensions>80:24x24;100:30x30;140:42x42;180:54x54</ExpectedScaleDimensions>
      <ExpectedTargetSizes>16;32;48;256</ExpectedTargetSizes>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m:VisualElements/m:DefaultTile/@WideLogo">
      <DescriptionID>WideLogo</DescriptionID>
      <ExpectedScaleDimensions>80:248x120;100:310x150;140:434x210;180:558x270</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m:VisualElements/m:LockScreen/@BadgeLogo">
      <DescriptionID>BadgeLogo</DescriptionID>
      <ExpectedScaleDimensions>100:24x24;140:33x33;180:43x43</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m:VisualElements/m:SplashScreen/@Image">
      <DescriptionID>SplashScreen</DescriptionID>
      <ExpectedScaleDimensions>100:620x300;140:868x420;180:1116x540</ExpectedScaleDimensions>
    </AppxManifestImageFileNameQuery>
  </ItemGroup>

  <ItemGroup Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:DefaultTile/@Square71x71Logo">
      <DescriptionID>Square71x71Logo</DescriptionID>
      <ExpectedScaleDimensions>400:284x284;200:142x142;100:71x71;150:107x107;125:89x89</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/@Square150x150Logo">
      <DescriptionID>Square150x150Logo</DescriptionID>
      <ExpectedScaleDimensions>400:600x600;200:300x300;100:150x150;150:225x225;125:188x188</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:DefaultTile/@Wide310x150Logo">
      <DescriptionID>Wide310x150Logo</DescriptionID>
      <ExpectedScaleDimensions>400:1240x600;200:620x300;100:310x150;150:465x225;125:388x188</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:DefaultTile/@Square310x310Logo">
      <DescriptionID>Square310x310Logo</DescriptionID>
      <ExpectedScaleDimensions>400:1240x1240;200:620x620;100:310x310;150:465x465;125:388x388</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/@Square44x44Logo">
      <DescriptionID>SmallLogo</DescriptionID>
      <ExpectedScaleDimensions>400:176x176;200:88x88;100:44x44;150:66x66;125:55x55</ExpectedScaleDimensions>
      <ExpectedTargetSizes>16;24;48;256</ExpectedTargetSizes>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Properties/m:Logo">
      <DescriptionID>StoreLogo</DescriptionID>
      <ExpectedScaleDimensions>400:200x200;200:100x100;150:75x75;125:63x63;100:50x50</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:LockScreen/@BadgeLogo">
      <DescriptionID>BadgeLogo</DescriptionID>
      <ExpectedScaleDimensions>400:96x96;200:48x48;150:36x36;125:30x30;100:24x24</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/uap:VisualElements/uap:SplashScreen/@Image">
      <DescriptionID>SplashScreen</DescriptionID>
      <ExpectedScaleDimensions>400:2480x1200;200:1240x600;150:930x450;125:775x375;100:620x300</ExpectedScaleDimensions>
    </AppxManifestImageFileNameQuery>
  </ItemGroup>

  <ItemGroup Condition="'$(TargetPlatformVersion)' != '8.0' and '$(AppxPackagePipelineVersion)' != '$(UapBuildPipeline)'">
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/@Square30x30Logo">
      <DescriptionID>Square30x30Logo</DescriptionID>
      <ExpectedScaleDimensions>80:24x24;100:30x30;140:42x42;180:54x54</ExpectedScaleDimensions>
      <ExpectedTargetSizes>16;32;48;256</ExpectedTargetSizes>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/@Square150x150Logo">
      <DescriptionID>Square150x150Logo</DescriptionID>
      <ExpectedScaleDimensions>80:120x120;100:150x150;140:210x210;180:270x270</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/m2:DefaultTile/@Wide310x150Logo">
      <DescriptionID>Wide310x150Logo</DescriptionID>
      <ExpectedScaleDimensions>80:248x120;100:310x150;140:434x210;180:558x270</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/m2:DefaultTile/@Square310x310Logo">
      <DescriptionID>Square310x310Logo</DescriptionID>
      <ExpectedScaleDimensions>80:248x248;100:310x310;140:434x434;180:558x558</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/m2:DefaultTile/@Square70x70Logo">
      <DescriptionID>Square70x70Logo</DescriptionID>
      <ExpectedScaleDimensions>80:56x56;100:70x70;140:98x98;180:126x126</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/m2:LockScreen/@BadgeLogo">
      <DescriptionID>BadgeLogo</DescriptionID>
      <ExpectedScaleDimensions>100:24x24;140:33x33;180:43x43</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m2:VisualElements/m2:SplashScreen/@Image">
      <DescriptionID>SplashScreen</DescriptionID>
      <ExpectedScaleDimensions>100:620x300;140:868x420;180:1116x540</ExpectedScaleDimensions>
    </AppxManifestImageFileNameQuery>
  </ItemGroup>

  <ItemGroup Condition="'$(TargetPlatformIdentifier)' != 'Windows' and '$(AppxPackagePipelineVersion)' != '$(UapBuildPipeline)'">
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/m3:DefaultTile/@Wide310x150Logo">
      <DescriptionID>Wide310x150Logo</DescriptionID>
      <ExpectedScaleDimensions>100:310x150;140:434x210;240:744x360</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/m3:DefaultTile/@Square310x310Logo">
      <DescriptionID>Square310x310Logo</DescriptionID>
      <ExpectedScaleDimensions>100:310x310;140:434x434;240:744x744</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/m3:DefaultTile/@Square71x71Logo">
      <DescriptionID>Square71x71Logo</DescriptionID>
      <ExpectedScaleDimensions>100:71x71;140:99x99;240:170x170</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/@Square44x44Logo">
      <DescriptionID>Square44x44Logo</DescriptionID>
      <ExpectedScaleDimensions>100:44x44;140:62x62;240:106x106</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/@Square150x150Logo">
      <DescriptionID>Square150x150Logo</DescriptionID>
      <ExpectedScaleDimensions>100:150x150;140:210x210;240:360x360</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/m3:SplashScreen/@Image">
      <DescriptionID>SplashScreen</DescriptionID>
      <ExpectedScaleDimensions>100:480x800;140:672x1120;240:1152x1920</ExpectedScaleDimensions>
    </AppxManifestImageFileNameQuery>
    <AppxManifestImageFileNameQuery Include="./m:Package/m:Applications/m:Application/m3:VisualElements/m3:LockScreen/@BadgeLogo">
      <DescriptionID>BadgeLogo</DescriptionID>
      <ExpectedScaleDimensions>100:24x24;140:33x33;240:58x58</ExpectedScaleDimensions>
      <MaximumFileSize>204800</MaximumFileSize>
    </AppxManifestImageFileNameQuery>
  </ItemGroup>

  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
    <AvailableItemName Include="AppxSourceContentGroupMap" />
  </ItemGroup>

  <!-- The reverse map needs to be added only in appx bundles and only on F5. -->
  <PropertyGroup Condition="'$(InsertReverseMap)' == ''">
    <InsertReverseMap Condition="'$(AppxBundle)' == 'Always' or '$(AppxBundle)' == 'Auto'">true</InsertReverseMap>
    <InsertReverseMap Condition="'$(InsertReverseMap)' == '' or '$(GenerateAppxPackageOnBuild)' == 'true' or '$(OutputType)' != 'WindowsWebApplication'">false</InsertReverseMap>
  </PropertyGroup>

  <PropertyGroup>
    <_ProjectPriFullPathOriginal>$(ProjectPriFullPath)</_ProjectPriFullPathOriginal>
  </PropertyGroup>

  <PropertyGroup Condition="'$(InsertReverseMap)' == 'true'">
    <_ReverseMapProjectPriDirectory>$([System.IO.Path]::GetDirectoryName('$(ProjectPriFullPath)'))\ReverseMap\</_ReverseMapProjectPriDirectory>
    <_ReverseMapProjectPriFileName>$([System.IO.Path]::GetFileName('$(ProjectPriFullPath)'))</_ReverseMapProjectPriFileName>
    <ProjectPriFullPath>$(_ReverseMapProjectPriDirectory)$(_ReverseMapProjectPriFileName)</ProjectPriFullPath>
  </PropertyGroup>

  <PropertyGroup Condition="'$(InsertReverseMap)' == 'true' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
    <_ReverseMapProjectPriUploadDirectory>$([System.IO.Path]::GetDirectoryName('$(ProjectPriUploadFullPath)'))\ReverseMap\</_ReverseMapProjectPriUploadDirectory>
    <_ReverseMapProjectPriUploadFileName>$([System.IO.Path]::GetFileName('$(ProjectPriUploadFullPath)'))</_ReverseMapProjectPriUploadFileName>
    <ProjectPriUploadFullPath>$(_ReverseMapProjectPriUploadDirectory)$(_ReverseMapProjectPriUploadFileName)</ProjectPriUploadFullPath>
  </PropertyGroup>

  <!-- This property is used to trigger a perf optimization in the CreatePriFilesForPortableLibraries task. -->
  <!-- When true we will skip generating an intermediate pri file in certain cases and instead just specify -->
  <!-- the resource file when generating the project's final pri file.                                      -->
  <PropertyGroup Condition="'$(SkipIntermediatePriGenerationForResourceFiles)' == ''">
    <SkipIntermediatePriGenerationForResourceFiles Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">true</SkipIntermediatePriGenerationForResourceFiles>
    <SkipIntermediatePriGenerationForResourceFiles Condition="'$(SkipIntermediatePriGenerationForResourceFiles)' == ''">false</SkipIntermediatePriGenerationForResourceFiles>
  </PropertyGroup>

  <!-- WinMDExp.exe is a tool needed to build WinMD files.  It normally ships as part of the .Net SDK, but  -->
  <!-- we point the common targets to our own copy so we don't require that dependency.                     -->
  <PropertyGroup>
    <WinMdExpToolPath Condition="'$(WinMdExpToolPath)' == '' and EXISTS( '$(AppxMSBuildToolsPath)WinMDExp.exe' ) ">$(AppxMSBuildToolsPath)</WinMdExpToolPath>
  </PropertyGroup>

  <!-- Manifest metadata items. -->

  <!-- Those will be transformed into Name/Value or Name/Version pairs as follows:                         -->
  <!--                                                                                                     -->
  <!-- If identity of the item (attribute 'Include') points to existing file and there is                  -->
  <!-- no supplied value or version, file version of given file will be extracted and stored               -->
  <!-- as Version attribute of metadata with name equal to file name and extension.                        -->
  <!--                                                                                                     -->
  <!-- If item has metadata 'Value', then it is directly stored in the manifest as name/value pair.        -->
  <!-- If item has metadata 'Version', then it is directly stored in the manifest as name/version pair.    -->
  <!--                                                                                                     -->
  <!-- If metadata 'Name' is supplied, it will be used instead of identity of the item. This is useful     -->
  <!-- if we use binary to extract file version, but want to give it different name in generated manifest. -->

  <ItemGroup Label="AppxManifestMetadata">

    <AppxManifestMetaData Include="SharedGUID" Condition="'$(SharedGUID)' != ''">
      <Value>$(SharedGUID)</Value>
    </AppxManifestMetaData>

    <AppxManifestMetaData Include="CodeSharingProject" Condition=" '$(HasSharedItems)' == 'true' or '$(CodeSharingProject)' != '' ">
      <Value Condition=" '$(CodeSharingProject)' != '' ">$(CodeSharingProject)</Value>
      <Value Condition=" '$(CodeSharingProject)' == '' ">248F659F-DAC5-46E8-AC09-60EC9FC95053</Value>
    </AppxManifestMetaData>

    <AppxManifestMetadata Include="TargetFrameworkMoniker" Condition="'$(TargetFrameworkMoniker)' != ''">
      <Value>$(TargetFrameworkMoniker)</Value>
    </AppxManifestMetadata>

    <AppxManifestMetadata Include="VisualStudio">
      <Version>$(VisualStudioVersion)</Version>
    </AppxManifestMetadata>

    <AppxManifestMetadata Include="VisualStudioEdition" Condition="'$(VisualStudioEdition)' != ''">
      <Value>$(VisualStudioEdition)</Value>
    </AppxManifestMetadata>

    <AppxManifestMetadata Include="$(ComSpec)">
      <Name>OperatingSystem</Name>
    </AppxManifestMetadata>

    <AppxManifestMetadata Include="$(AppxMSBuildToolsPath)Microsoft.Build.AppxPackage.dll" />

    <AppxManifestMetaData Include="ProjectGUID" Condition="'$(ProjectGUID)' != ''">
      <Value>$(ProjectGUID)</Value>
    </AppxManifestMetaData>

  </ItemGroup>

  <Import Project="$(MSBuildProjectDirectory)\Microsoft.AppxPackage.Metadata.Overrides.props" Condition="EXISTS( '$(MSBuildProjectDirectory)\Microsoft.AppxPackage.Metadata.Overrides.props' )"/>

  <!-- Mapping between OS version (6.*) and marketing version string. -->
  <!-- There is no guarantee that NTVersion always consists of first two parts of OSVersion, hence a separate field. -->
  <ItemGroup>
    <PlatformVersionDescription Include="Windows 8.0">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.0</TargetPlatformVersion>
      <OSDescription>Windows 8.0</OSDescription>
      <OSVersion>6.2.1</OSVersion>
      <NTVersion>6.2</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows 8.1">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows 8.1</OSDescription>
      <OSVersion>6.3.0</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows Phone 8.1">
      <TargetPlatformIdentifier>WindowsPhoneApp</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows Phone 8.1</OSDescription>
      <OSVersion>6.3.1</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows Phone Silverlight 8.1">
      <TargetPlatformIdentifier>Windows Phone</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.1</TargetPlatformVersion>
      <OSDescription>Windows Phone 8.1</OSDescription>
      <OSVersion>6.3.1</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="Windows 8.2">
      <TargetPlatformIdentifier>Windows</TargetPlatformIdentifier>
      <TargetPlatformVersion>8.2</TargetPlatformVersion>
      <OSDescription>Windows 8.2</OSDescription>
      <OSVersion>6.3.0</OSVersion>
      <NTVersion>6.3</NTVersion>
    </PlatformVersionDescription>
    <PlatformVersionDescription Include="UAP 1.0">
      <TargetPlatformIdentifier>UAP</TargetPlatformIdentifier>
      <TargetPlatformVersion>0.8.0.0</TargetPlatformVersion>
      <OSDescription>Windows 10.0</OSDescription>
      <OSVersion>10.0.0</OSVersion>
      <NTVersion>10.0</NTVersion>
    </PlatformVersionDescription>
  </ItemGroup>

  <!-- Packaging output group default values -->
  <PropertyGroup>
    <IncludeBuiltProjectOutputGroup Condition="'$(IncludeBuiltProjectOutputGroup)' == ''">true</IncludeBuiltProjectOutputGroup>
    <IncludeDebugSymbolsProjectOutputGroup Condition="'$(IncludeDebugSymbolsProjectOutputGroup)' == ''">true</IncludeDebugSymbolsProjectOutputGroup>
    <IncludeDocumentationProjectOutputGroup Condition="'$(IncludeDocumentationProjectOutputGroup)' == ''">false</IncludeDocumentationProjectOutputGroup>
    <IncludeSatelliteDllsProjectOutputGroup Condition="'$(IncludeSatelliteDllsProjectOutputGroup)' == ''">false</IncludeSatelliteDllsProjectOutputGroup>
    <IncludeSourceFilesProjectOutputGroup Condition="'$(IncludeSourceFilesProjectOutputGroup)' == ''">false</IncludeSourceFilesProjectOutputGroup>
    <IncludeContentFilesProjectOutputGroup Condition="'$(IncludeContentFilesProjectOutputGroup)' == ''">true</IncludeContentFilesProjectOutputGroup>
    <IncludeSGenFilesOutputGroup Condition="'$(IncludeSGenFilesOutputGroup)' == ''">false</IncludeSGenFilesOutputGroup>
    <IncludeCopyLocalFilesOutputGroup Condition="'$(IncludeCopyLocalFilesOutputGroup)' == ''">true</IncludeCopyLocalFilesOutputGroup>
    <IncludeOptionalProjectsOutputGroup Condition="'$(IncludeOptionalProjectsOutputGroup)' == ''">true</IncludeOptionalProjectsOutputGroup>
    <IncludeComFilesOutputGroup Condition="'$(IncludeComFilesOutputGroup)' == ''">false</IncludeComFilesOutputGroup>
    <IncludeCustomOutputGroupForPackaging Condition="'$(IncludeCustomOutputGroupForPackaging)' == ''">false</IncludeCustomOutputGroupForPackaging>
    <IncludeCopyWinmdArtifactsOutputGroup Condition="'$(IncludeCopyWinmdArtifactsOutputGroup)' == ''">true</IncludeCopyWinmdArtifactsOutputGroup>
    <IncludeSDKRedistOutputGroup Condition="'$(IncludeSDKRedistOutputGroup)' == ''">true</IncludeSDKRedistOutputGroup>
    <IncludePriFilesOutputGroup Condition="'$(IncludePriFilesOutputGroup)' == ''">true</IncludePriFilesOutputGroup>
    <IncludeGetResolvedSDKReferences Condition="'$(IncludeGetResolvedSDKReferences)' == ''">true</IncludeGetResolvedSDKReferences>
    <IncludeProjectPriFile Condition="'$(IncludeProjectPriFile)' == ''">true</IncludeProjectPriFile>
  </PropertyGroup>

  <!-- Entry points for the project systems. -->
  <PropertyGroup Condition="'$(AppxPackage)' == 'true'">
    <CleanPackageAction>_CleanAppxPackage</CleanPackageAction>
    <PackageAction>_GenerateAppxPackage</PackageAction>
    <RebuildPackageAction>_RebuildAppxPackage</RebuildPackageAction>
  </PropertyGroup>

  <!-- Tie into rebuild sequence, to set flag if we are doing rebuilding. -->
  <Target Name="_BeforeBeforeRebuild" BeforeTargets="BeforeRebuild">
    <PropertyGroup>
      <_Rebuilding>true</_Rebuilding>
    </PropertyGroup>
  </Target>

  <!-- Alter behavior of task ResolveAssemblyReferences to error on architecture mismatch. -->
  <PropertyGroup>
    <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>Error</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
  </PropertyGroup>

  <!-- ============================================================================================ -->
  <!-- Overriding Publish target from Microsoft.Common.targets to tie into command-line publishing. -->
  <!-- ============================================================================================ -->

  <Target Name="Publish"
          Condition="'$(AppxPackage)' == 'true'"
          DependsOnTargets="Build;$(PackageAction)" />


  <!--
    ***********************************************************************************************
    ***********************************************************************************************
        Actions happening during the build
    ***********************************************************************************************
    ***********************************************************************************************
    -->
  <PropertyGroup>
    <PrepareForRunDependsOn>
      $(PrepareForRunDependsOn);
      _ValidatePaths;
      _ComputeBuildAppxUploadPackageForUapFlag;
      _GetAppxManifestSchemaItems;
      _FindAndValidateBundleMappingFile;
      _GetSdkToolPaths;
      _GetPriConfigXmlSnippets;
      _ValidatePresenceOfAppxManifestItems;
      GetPackagingOutputs;
      _GetPackageProperties;
      _AddUnionWinmd;
      _AddFxWinmd;
      _GenerateProjectPriFile;
      _ComputeAppxPackagePayload;
      _GenerateAppxManifest;
      _ValidateStoreManifest;
      _BuildOptionalProjects;
      _GenerateBundleMappingFile;
      _GenerateBundleManifest;
      _GenerateAppxPackageRecipe;
      _GenerateAppxUploadPackageRecipe;
      _ConvertAppxContentGroupMap;
    </PrepareForRunDependsOn>
    <PrepareForRunDependsOn Condition=" '$(GenerateAppxPackageOnBuild)' == 'true'">
      $(PrepareForRunDependsOn);
      $(PackageAction)
    </PrepareForRunDependsOn>
    <PrepareForRunDependsOn>
      $(PrepareForRunDependsOn);
      _AppendToReadTlogFile;
      _AppendToWriteTlogFile;
      _AppendToPackagingWriteLogs
    </PrepareForRunDependsOn>
  </PropertyGroup>

  <!-- Validates directory paths and ensures trailing slashes -->
  <Target Name="_ValidatePaths">

    <PropertyGroup>
      <AppxPackageDir Condition="!HasTrailingSlash('$(AppxPackageDir)')">$(AppxPackageDir)\</AppxPackageDir>
      <AppxLayoutDir Condition="!HasTrailingSlash('$(AppxLayoutDir)')">'$(AppxLayoutDir)'\</AppxLayoutDir>
      <AppxUploadLayoutDir Condition="!HasTrailingSlash('$(AppxUploadLayoutDir)')">$(AppxUploadLayoutDir)\</AppxUploadLayoutDir>
      <PlatformSpecificBundleArtifactsListDir Condition="!HasTrailingSlash('$(PlatformSpecificBundleArtifactsListDir)')">$(PlatformSpecificBundleArtifactsListDir)\</PlatformSpecificBundleArtifactsListDir>
      <PlatformSpecificUploadBundleArtifactsListDir Condition="'$(PlatformSpecificUploadBundleArtifactsListDir)' == ''">$(PlatformSpecificBundleArtifactsListDir)Upload\</PlatformSpecificUploadBundleArtifactsListDir>
    </PropertyGroup>

  </Target>

  <!-- Calculates AppxManifestSchema items. -->
  <Target Name="_GetAppxManifestSchemaItems"
          Condition="'@(AppxManifestSchema)' == ''">

    <GetSdkPropertyValue Condition="'$(TargetPlatformIdentifier)' == 'Windows'"
                         TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="WindowsSDK80Path">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>

    <GetSdkPropertyValue Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'"
                         TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="WindowsPhoneSdkDir">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>

    <GetSdkPropertyValue Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'"
                         TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="WindowsSdkDir">
      <Output TaskParameter="PropertyValue" PropertyName="_TargetPlatformSdkDir" />
    </GetSdkPropertyValue>

    <ItemGroup Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' == '8.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>

    <ItemGroup Condition="'$(TargetPlatformIdentifier)' == 'Windows' and '$(TargetPlatformVersion)' != '8.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2010_v2.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2013.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>

    <ItemGroup Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and '$(SDKVersion)' == '10.0'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\$(TargetPlatformVersion)\WinRT\FoundationManifestSchema.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/foundation/windows10</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\$(TargetPlatformVersion)\WinRT\UapManifestSchema.xsd">
        <NamespaceAlias>uap</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/manifest/uap/windows10</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>

    <ItemGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2010_v3.xsd">
        <NamespaceAlias>m</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2013_v2.xsd">
        <NamespaceAlias>m2</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2013/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxManifestSchema2014.xsd">
        <NamespaceAlias>m3</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2014/manifest</NamespaceUri>
      </AppxManifestSchema>
      <AppxManifestSchema Include="$(_TargetPlatformSdkDir)\Include\WinRT\AppxPhoneManifestSchema2014.xsd">
        <NamespaceAlias>mp</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2014/phone/manifest</NamespaceUri>
      </AppxManifestSchema>
    </ItemGroup>

    <PropertyGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true' and Exists('$(_TargetPlatformSdkDir)\Include\WinRT\StoreManifest.xsd')">
      <_StoreManifestSchemaDir>$(_TargetPlatformSdkDir)\Include\WinRT\</_StoreManifestSchemaDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true' and !Exists('$(_TargetPlatformSdkDir)\Include\WinRT\StoreManifest.xsd')">
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_CURRENT_USER\SOFTWARE\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <CURRENTVSINSTALLDIR Condition="'$(CURRENTVSINSTALLDIR)' == ''">$(registry:HKEY_CURRENT_USER\SOFTWARE\Wow6432Node\Microsoft\VisualStudio\SxS\VS7@15.0)</CURRENTVSINSTALLDIR>
      <_StoreManifestSchemaDir>$(CURRENTVSINSTALLDIR)Xml\Schemas\</_StoreManifestSchemaDir>
    </PropertyGroup>

    <ItemGroup Condition="'$(_TargetPlatformIsWindowsPhone)' == 'true'">
      <StoreManifestSchema Include="$(_StoreManifestSchemaDir)StoreManifest.xsd">
        <NamespaceAlias>store</NamespaceAlias>
        <NamespaceUri>http://schemas.microsoft.com/appx/2010/StoreManifest</NamespaceUri>
      </StoreManifestSchema>
    </ItemGroup>

    <!--
            Define AppxValidateStoreManifest based on whether we ended up with any
            StoreManifestSchemas or not.  This keeps the logic agnostic about which
            TargetPlatform/Version supports validating the Store manifest.
        -->
    <PropertyGroup>
      <AppxValidateStoreManifest Condition="'$(AppxValidateStoreManifest)' == '' and '@(StoreManifestSchema)' != ''">true</AppxValidateStoreManifest>
    </PropertyGroup>

    <PropertyGroup>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == '' and '$(SDKIdentifier)' != ''">http://schemas.microsoft.com/developer/appx/2015/build</MetadataNamespaceUri>
      <MetadataNamespaceUri Condition="'$(MetadataNamespaceUri)' == ''">http://schemas.microsoft.com/developer/appx/2012/build</MetadataNamespaceUri>
    </PropertyGroup>
  </Target>

  <!-- Finds SDK tool executables paths. -->
  <Target Name="_GetSdkToolPaths">

    <PropertyGroup>
      <MSBuildExtensionsPath64Exists Condition="'$(MSBuildExtensionsPath64)' == ''">false</MSBuildExtensionsPath64Exists>
      <MSBuildExtensionsPath64Exists Condition="'$(MSBuildExtensionsPath64)' != ''">true</MSBuildExtensionsPath64Exists>
    </PropertyGroup>

    <GetSdkFileFullPath Condition="'$(AppxGeneratePriEnabled)' == 'true' or '$(AppxGeneratePrisForPortableLibrariesEnabled)' == 'true'"
                        FileName="MakePri.exe"
                        FullFilePath="$(MakePriExeFullPath)"
                        FileArchitecture="$(MakePriArchitecture)"
                        RequireExeExtension="true"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        SDKIdentifier="$(SDKIdentifier)"
                        SDKVersion="$(SDKVersion)"
                        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                        TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MakePriExeFullPath" />
      <Output TaskParameter="ActualFileArchitecture" PropertyName="MakePriArchitecture" />
    </GetSdkFileFullPath>

    <Message Importance="low" Text="MakePriExeFullPath: $(MakePriExeFullPath)" />
    <Message Importance="low" Text="MakePriArchitecture: $(MakePriArchitecture)" />

    <GetSdkFileFullPath Condition="'$(AppxPackage)' == 'true' or '$(GenerateAppxPackageOnBuild)' == 'true' or '@(BundleMappingFile)' != ''"
                        FileName="MakeAppx.exe"
                        FullFilePath="$(MakeAppxExeFullPath)"
                        FileArchitecture="$(MakeAppxArchitecture)"
                        RequireExeExtension="true"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        SDKIdentifier="$(SDKIdentifier)"
                        SDKVersion="$(SDKVersion)"
                        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                        TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MakeAppxExeFullPath" />
    </GetSdkFileFullPath>

    <Message Importance="low" Text="MakeAppxExeFullPath: $(MakeAppxExeFullPath)" />

    <GetSdkFileFullPath Condition="'$(AppxPackage)' == 'true' or '$(GenerateAppxPackageOnBuild)' == 'true'"
                        FileName="signtool.exe"
                        FullFilePath="$(SignAppxPackageExeFullPath)"
                        FileArchitecture="$(SignToolArchitecture)"
                        RequireExeExtension="true"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        SDKIdentifier="$(SDKIdentifier)"
                        SDKVersion="$(SDKVersion)"
                        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                        TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="SignAppxPackageExeFullPath" />
    </GetSdkFileFullPath>

    <Message Importance="low" Text="SignAppxPackageExeFullPath: $(SignAppxPackageExeFullPath)" />

    <PropertyGroup Condition="'$(AppxPackagingArchitecture)' == ''">
      <AppxPackagingArchitecture Condition="$([System.Environment]::Is64BitProcess)">x64</AppxPackagingArchitecture>
      <AppxPackagingArchitecture Condition="!$([System.Environment]::Is64BitProcess)">x86</AppxPackagingArchitecture>
    </PropertyGroup>

    <GetSdkFileFullPath Condition="'$(SDKIdentifier)' != ''"
                        FileName="Microsoft.Windows.Build.Appx.AppxPackaging.dll.manifest"
                        FullFilePath="$(AppxPackagingComponentManifestPath)"
                        FileArchitecture="$(AppxPackagingArchitecture)"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        SDKIdentifier="$(SDKIdentifier)"
                        SDKVersion="$(SDKVersion)"
                        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                        TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="AppxPackagingComponentManifestPath" />
    </GetSdkFileFullPath>

    <Message Importance="low" Text="AppxPackagingComponentManifestPath: $(AppxPackagingComponentManifestPath)" />

    <PropertyGroup Condition="'$(MrmSupportLibraryArchitecture)' == ''">
      <MrmSupportLibraryArchitecture Condition="$([System.Environment]::Is64BitProcess)">x64</MrmSupportLibraryArchitecture>
      <MrmSupportLibraryArchitecture Condition="!$([System.Environment]::Is64BitProcess)">x86</MrmSupportLibraryArchitecture>
    </PropertyGroup>

    <GetSdkFileFullPath Condition="'$(SDKIdentifier)' != ''"
                        FileName="MrmSupport.dll"
                        FullFilePath="$(MrmSupportLibraryPath)"
                        FileArchitecture="$(MrmSupportLibraryArchitecture)"
                        TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                        SDKIdentifier="$(SDKIdentifier)"
                        SDKVersion="$(SDKVersion)"
                        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                        TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                        TargetPlatformVersion="$(TargetPlatformVersion)"
                        MSBuildExtensionsPath64Exists="$(MSBuildExtensionsPath64Exists)">
      <Output TaskParameter="ActualFullFilePath" PropertyName="MrmSupportLibraryPath" />
    </GetSdkFileFullPath>

    <Message Importance="low" Text="MrmSupportLibraryPath: $(MrmSupportLibraryPath)" />

    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="MakePriExtensionPath"
                         Condition="'$(MakePriExtensionPath)' == '' and '$(SDKIdentifier)' == ''">
      <Output TaskParameter="PropertyValue" PropertyName="MakePriExtensionPath" />
    </GetSdkPropertyValue>

    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="MakePriExtensionPath_x64"
                         Condition="'$(MakePriExtensionPath_x64)' == '' and '$(SDKIdentifier)' == ''">
      <Output TaskParameter="PropertyValue" PropertyName="MakePriExtensionPath_x64" />
    </GetSdkPropertyValue>

    <!--Clear out MakePriExtensionPath for UAP projects since it should never be used.-->
    <PropertyGroup Condition="'$(SDKIdentifier)' != ''">
      <MakePriExtensionPath></MakePriExtensionPath>
      <MakePriExtensionPath_x64></MakePriExtensionPath_x64>
    </PropertyGroup>

    <Message Importance="low" Text="MakePriExtensionPath: $(MakePriExtensionPath)" />
    <Message Importance="low" Text="MakePriExtensionPath_x64: $(MakePriExtensionPath_x64)" />

    <PropertyGroup>
      <OutOfProcessMakePriExtensionPath Condition="'$(MakePriArchitecture)' != 'amd64'">$(MakePriExtensionPath)</OutOfProcessMakePriExtensionPath>
      <OutOfProcessMakePriExtensionPath Condition="'$(MakePriArchitecture)' == 'amd64'">$(MakePriExtensionPath_x64)</OutOfProcessMakePriExtensionPath>
    </PropertyGroup>

    <Message Importance="low" Text="OutOfProcessMakePriExtensionPath: $(OutOfProcessMakePriExtensionPath)" />

    <PropertyGroup>
      <InProcessMakePriExtensionPath Condition="!$([System.Environment]::Is64BitProcess)">$(MakePriExtensionPath)</InProcessMakePriExtensionPath>
      <InProcessMakePriExtensionPath Condition="$([System.Environment]::Is64BitProcess)">$(MakePriExtensionPath_x64)</InProcessMakePriExtensionPath>
    </PropertyGroup>

    <Message Importance="low" Text="InProcessMakePriExtensionPath: $(InProcessMakePriExtensionPath)" />

  </Target>

  <!-- Calculates paths to priconfig.xml snippets -->
  <Target Name="_GetPriConfigXmlSnippets">

    <ItemGroup Condition="'$(AppxPriConfigXmlPackagingSnippetPath)' == ''">
      <_AppxPriConfigXmlPackagingSnippetItem Include="@(None)" Condition="'%(Identity)' == 'priconfig.packaging.xml'" />
      <_AppxPriConfigXmlPackagingSnippetItem Include="@(Xml)" Condition="'%(Identity)' == 'priconfig.packaging.xml' and '%(Xml.DeploymentContent)' == 'false'" />
    </ItemGroup>

    <PropertyGroup Condition="'@(_AppxPriConfigXmlPackagingSnippetItem)' != ''">
      <AppxPriConfigXmlPackagingSnippetPath>%(_AppxPriConfigXmlPackagingSnippetItem.FullPath)</AppxPriConfigXmlPackagingSnippetPath>
    </PropertyGroup>

    <ItemGroup Condition="'$(AppxPriConfigXmlDefaultSnippetPath)' == ''">
      <_AppxPriConfigXmlDefaultSnippetItem Include="@(None)" Condition="'%(Identity)' == 'priconfig.default.xml'" />
      <_AppxPriConfigXmlDefaultSnippetItem Include="@(Xml)" Condition="'%(Identity)' == 'priconfig.default.xml' and '%(Xml.DeploymentContent)' == 'false'" />
    </ItemGroup>

    <PropertyGroup Condition="'@(_AppxPriConfigXmlDefaultSnippetItem)' != ''">
      <AppxPriConfigXmlDefaultSnippetPath>%(_AppxPriConfigXmlDefaultSnippetItem.FullPath)</AppxPriConfigXmlDefaultSnippetPath>
    </PropertyGroup>

  </Target>

  <PropertyGroup>
    <ValidatePresenceOfAppxManifestItemsDependsOn>
      $(ValidatePresenceOfAppxManifestItemsDependsOn);
    </ValidatePresenceOfAppxManifestItemsDependsOn>
  </PropertyGroup>

  <!-- Finds out if there is a custom AppxManifest override item, -->
  <!-- validates that one and only one manifest exists,           -->
  <!-- extracts identity name and version out of the manifest,    -->
  <!-- defines ProjectPriIndexName,                               -->
  <!-- and defines SourceAppxManifest item.                       -->
  <Target Name="_ValidatePresenceOfAppxManifestItems"
          DependsOnTargets="$(ValidatePresenceOfAppxManifestItemsDependsOn)"
            >

    <ItemGroup>
      <CustomAppxManifest Include="@(Content)" Condition="'%(Identity)' == '$(AppxManifestFileName)'" />
    </ItemGroup>

    <ValidateAppxManifestItems AppxPackageProject="$(AppxPackage)"
                               AppxManifestItems="@(AppxManifest)"
                               CustomAppxManifestItems="@(CustomAppxManifest)">
      <Output TaskParameter="IdentityName" PropertyName="AppxManifestIdentityName" />
      <Output TaskParameter="IdentityVersion" PropertyName="AppxManifestIdentityVersion" />
    </ValidateAppxManifestItems>

    <ItemGroup>
      <SourceAppxManifest Include="@(AppxManifest)" Condition="'@(AppxManifest)' != ''" />
      <SourceAppxManifest Include="@(CustomAppxManifest)" Condition="'@(CustomAppxManifest)' != ''" />
    </ItemGroup>

    <PropertyGroup Condition="'$(ProjectPriIndexName)' == ''">
      <ProjectPriIndexName Condition="'$(AppxPackage)' == 'true'">$(AppxManifestIdentityName)</ProjectPriIndexName>
      <ProjectPriIndexName Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)</ProjectPriIndexName>
    </PropertyGroup>

    <PropertyGroup>
      <_CustomAppxManifestUsed Condition="'@(CustomAppxManifest)' == ''">false</_CustomAppxManifestUsed>
      <_CustomAppxManifestUsed Condition="'@(CustomAppxManifest)' != ''">true</_CustomAppxManifestUsed>
    </PropertyGroup>
  </Target>

  <!-- ============================ -->
  <!-- Generating project PRI file. -->
  <!-- ============================ -->

  <PropertyGroup>
    <_GenerateProjectPriFileDependsOn>
      $(_GenerateProjectPriFileDependsOn);
      BeforeGenerateProjectPriFile;
      _GeneratePrisForPortableLibraries;
      _GetPriFilesFromPayload;
      _ComputeInputPriFiles;
      _GenerateProjectPriConfigurationFiles;
      _CalculateInputsForGenerateProjectPriFileCore;
      _GenerateProjectPriFileCore;
      _AddFileReadsAndFileWritesForProjectPri;
      _CreateProjectPriFileItem;
      _ExpandProjectPriFile;
      _ExpandPriFiles;
      _ExpandPriUploadFiles;
      AfterGenerateProjectPriFile
    </_GenerateProjectPriFileDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <_SupportEmbedFileResources Condition="'$(_SupportEmbedFileResources)' =='' AND '$(TargetPlatformIdentifier)' == 'UAP'">true</_SupportEmbedFileResources>
    <_SupportXbfAsEmbedFileResources Condition="'$(DisableEmbeddedXbf)' == 'true'">false</_SupportXbfAsEmbedFileResources>
    <_SupportXbfAsEmbedFileResources Condition="'$(_SupportXbfAsEmbedFileResources)' == '' AND '$(_SupportEmbedFileResources)' == 'true'">true</_SupportXbfAsEmbedFileResources>
    <_PriConfigXmlPath>$(IntermediateOutputPath)priconfig.xml</_PriConfigXmlPath>
    <_LayoutResfilesPath>$(IntermediateOutputPath)layout.resfiles</_LayoutResfilesPath>
    <_ResourcesResfilesPath>$(IntermediateOutputPath)resources.resfiles</_ResourcesResfilesPath>
    <_PriResfilesPath>$(IntermediateOutputPath)pri.resfiles</_PriResfilesPath>
    <_EmbedFileResfilePath Condition="'$(_SupportEmbedFileResources)' == 'true'">$(IntermediateOutputPath)embed.resfiles</_EmbedFileResfilePath>
    <_QualifiersPath>$(IntermediateOutputPath)qualifiers.txt</_QualifiersPath>
    <_MultipleQualifiersPerDimensionFoundPath>$(IntermediateOutputPath)MultipleQualifiersPerDimensionFound.txt</_MultipleQualifiersPerDimensionFoundPath>
  </PropertyGroup>

  <Target Name="_GenerateProjectPriFile"
          Condition="'$(AppxGeneratePriEnabled)' == 'true'"
          DependsOnTargets="$(_GenerateProjectPriFileDependsOn)"
            />

  <!-- Override to specify actions to happen before generating project PRI file. -->
  <Target Name="BeforeGenerateProjectPriFile" />

  <!-- Generates a PRI file for all managed libraries that contain .resources files   -->
  <!-- in them (and their satellites).  This allows a .NET Portable Library to be     -->
  <!-- built with only .resources files, yet still be localized when compiled into    -->
  <!-- an AppX package where the ResourceManager uses the WinRT resource manager.     -->
  <Target Name="_GeneratePrisForPortableLibraries"
          Condition="'$(AppxPackage)' == 'true' and '$(AppxGeneratePrisForPortableLibrariesEnabled)' == 'true'"
            >
    <!-- 
    Do not rename or delete the item groups _LibrariesUnfiltered and CreatedResWFiles

    In case of compiling Universal app, the item group _LibrariesUnfiltered will get initialized with the filtered list of 
    the app assemblies excluding the framework assemblies. 
    the initialization will occur in the target _GetLibrariesToGeneratePrisForUWPApps in the file Microsoft.Net.CoreRuntime.targets. 
    also _GetLibrariesToGeneratePrisForUWPApps will fill the initial list of CreatedResWFiles. 
    -->

    <ItemGroup Condition="'@(_LibrariesUnfiltered)' == '' and '@(CreatedResWFiles)' == ''">
      <_LibrariesUnfiltered Include="@(PackagingOutputs)" Condition="'%(Extension)' == '.dll'" />
    </ItemGroup>

    <RemovePayloadDuplicates Inputs="@(_LibrariesUnfiltered)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_LibrariesFiltered" />
    </RemovePayloadDuplicates>

    <ItemGroup>
      <_Libraries Include="@(_LibrariesFiltered)" Condition="'%(_LibrariesFiltered.BaseAssemblyFullPath)' == ''" />
      <_Libraries Include="@(_LibrariesFiltered)" Condition="'%(_LibrariesFiltered.BaseAssemblyFullPath)' != ''">
        <OriginalItemSpec>%(_LibrariesFiltered.BaseAssemblyFullPath)</OriginalItemSpec>
      </_Libraries>
    </ItemGroup>

    <GenerateResource
                SdkToolsPath="$(ResgenToolPath)"
                ExtractResWFiles="true"
                Sources="@(_Libraries)"
                UseSourcePath="$(UseSourcePath)"
                References="@(ReferencePath)"
                AdditionalInputs="$(MSBuildAllProjects)"
                NeverLockTypeAssemblies="$(GenerateResourceNeverLockTypeAssemblies)"
                StateFile="$(IntermediateOutputPath)$(MSBuildProjectFile).GenerateResource.Cache"
                OutputDirectory="$(IntermediateOutputPath)"
                ExecuteAsTool="false"
                MSBuildRuntime="$(GenerateResourceMSBuildRuntime)"
                MSBuildArchitecture="$(GenerateResourceMSBuildArchitecture)">

      <Output TaskParameter="FilesWritten" ItemName="ExtractedFileWrites"/>
      <Output TaskParameter="OutputResources" ItemName="CreatedResWFiles" />
    </GenerateResource>

    <ItemGroup>
      <FileWrites Include="@(ExtractedFileWrites)" />
    </ItemGroup>

    <Message Importance="low" Text="Created resource files: @(CreatedResWFiles)" />

    <!-- Now generate a PRI file for each set of ResW files (ie, a main assembly + all satellites). -->
    <!-- Note: The task relies on some metadata set on each ITaskItem, set by GenerateResource.  -->

    <CreatePriFilesForPortableLibraries
                    MakePriExeFullPath="$(MakePriExeFullPath)"
                    MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                    ContentToIndex="@(CreatedResWFiles)"
                    IntermediateDirectory="$(IntermediateOutputPath)"
                    AdditionalMakepriExeParameters="$(AppxCreatePriFilesForPortableLibrariesAdditionalMakepriExeParameters)"
                    DefaultResourceLanguage="$(DefaultResourceLanguage)"
                    DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
                    IntermediateExtension="$(AppxIntermediateExtension)"
                    TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                    TargetPlatformVersion="$(TargetPlatformResourceVersion)"
                    AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                    SkipIntermediatePriGenerationForResourceFiles="$(SkipIntermediatePriGenerationForResourceFiles)"
                        >
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
      <Output TaskParameter="CreatedPriFiles" ItemName="_PortableLibraryCreatedPriFiles" />
      <Output TaskParameter="UnprocessedReswFiles_DefaultLanguage" ItemName="_UnprocessedReswFiles_DefaultLanguage" />
      <Output TaskParameter="UnprocessedReswFiles_OtherLanguages" ItemName="_UnprocessedReswFiles_OtherLanguages" />
    </CreatePriFilesForPortableLibraries>

    <Message Importance="low" Text="Created PRI files: @(_PortableLibraryCreatedPriFiles)" />

    <!-- Add all resw files we didn't generate a pri file for to the PRIResource group so they get included during           -->
    <!-- final pri generation, with the exception of those that need to be indexed using a language other than the project's -->
    <!-- default.  This group will always be empty if SkipIntermediatePriGenerationForResourceFiles is false.                -->
    <ItemGroup>
      <PRIResource Include="@(_UnprocessedReswFiles_DefaultLanguage)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="@(_PortableLibraryCreatedPriFiles)" />
    </ItemGroup>

  </Target>

  <!-- Get list of PRI files from the payload. -->
  <Target Name="_GetPriFilesFromPayload"
          Condition="'$(AppxPackage)' == 'true'"
            >

    <ItemGroup>
      <_PriFilesFromPayloadRaw Include="@(PackagingOutputs)"
                               Condition="'%(Extension)' == '.pri' 
                                            and '%(ProjectName)' != '$(ProjectName)'"
                                     />
      <_PriFilesFromPayloadRaw Include="@(PackagingOutputs)"
                               Condition="'%(Extension)' == '.pri' 
                                            and '%(ProjectName)' == '$(ProjectName)' 
                                            and '%(OutputGroup)' != 'ProjectPriFile'"
                                     />
    </ItemGroup>

    <RemoveDuplicatePriFiles Inputs="@(_PriFilesFromPayloadRaw)"
                             Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_PriFilesFromPayload" />
    </RemoveDuplicatePriFiles>

  </Target>

  <!-- Compute final list of input PRI files. -->
  <Target Name="_ComputeInputPriFiles"
          Condition="'$(AppxPackage)' == 'true'"
            >

    <ItemGroup>
      <_PriFile Include="@(_PriFilesFromPayload)" />
      <_PriFile Include="@(_PortableLibraryCreatedPriFiles)" />
    </ItemGroup>

  </Target>

  <!-- Generates configuration files for makepri.exe. -->
  <Target Name="_GenerateProjectPriConfigurationFiles"
          Inputs="$(MSBuildAllProjects);@(_PriFile);$(AppxPriConfigXmlDefaultSnippetPath);@(PackagingOutputs)"
          Outputs="$(_PriConfigXmlPath);$(_LayoutResfilesPath);$(_ResourcesResfilesPath);$(_PriResfilesPath)"
            >

    <ItemGroup>
      <_LayoutFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'ContentFilesProjectOutputGroup' and '%(ProjectName)' == '$(ProjectName)'" />
      <_LayoutFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'CustomOutputGroupForPackaging' and '%(ProjectName)' == '$(ProjectName)'" />
      <_EmbedFile Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == 'EmbedOutputGroupForPackaging' and '%(ProjectName)' == '$(ProjectName)'"/>
      <_EmbedFileCopy Include="@(_EmbedFile->'$(IntermediateOutputPath)%(TargetPath)')" />
    </ItemGroup>

    <GeneratePriConfigurationFiles
          LayoutResfilesPath="$(_LayoutResfilesPath)"
          ResourcesResfilesPath="$(_ResourcesResfilesPath)"
          PriResfilesPath="$(_PriResfilesPath)"
          EmbedFileResfilePath="$(_EmbedFileResfilePath)"
          LayoutFiles="@(_LayoutFile)"
          PRIResourceFiles="@(PRIResource)"
          PriFiles="@(_PriFile)"
          EmbedFiles="@(_EmbedFile)"
          IntermediateExtension="$(AppxIntermediateExtension)"
          UnprocessedResourceFiles_OtherLanguages="@(_UnprocessedReswFiles_OtherLanguages)">
      <Output TaskParameter="AdditionalResourceResFiles" ItemName="_AdditionalResourceResFiles" />
    </GeneratePriConfigurationFiles>

    <CreatePriConfigXmlForFullIndex
        PriConfigXmlPath="$(_PriConfigXmlPath)"
        LayoutResfilesPath="$(_LayoutResfilesPath)"
        ResourcesResfilesPath="$(_ResourcesResfilesPath)"
        PriResfilesPath="$(_PriResfilesPath)"
        EmbedFileResfilePath="$(_EmbedFileResfilePath)"
        PriInitialPath="$(AppxPriInitialPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        IntermediateExtension="$(AppxIntermediateExtension)"
        PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformResourceVersion)"
        AdditionalResourceResFiles="@(_AdditionalResourceResFiles)"
            />

    <!-- Copy Embed files to location expected by embed indexer-->
    <Copy
        SourceFiles="@(_EmbedFile)"
        DestinationFiles="@(_EmbedFileCopy)"
        SkipUnchangedFiles='true'
            />

    <Message Text="$(MSBuildProjectName) -> $(_PriConfigXmlPath)" />
    <Message Text="$(MSBuildProjectName) -> $(_LayoutResfilesPath)" />
    <Message Text="$(MSBuildProjectName) -> $(_ResourcesResfilesPath)" />
    <Message Text="$(MSBuildProjectName) -> $(_PriResfilesPath)" />
    <Message Text="$(MSBuildProjectName) -> $(_AdditionalResourceResFiles)" />
    <Message Condition="'$(_SupportEmbedFileResources)' == 'true'" Text="$(MSBuildProjectName) -> $(_EmbedFileResfilePath)" />

  </Target>

  <Target Name="_SuppressDeploymentOnlyFeatures">

    <!-- Disable adding the reverse map to the PRI file. This is necessary when building from the packaging wizard. -->
    <PropertyGroup>
      <InsertReverseMap>false</InsertReverseMap>
      <ProjectPriFullPath>$(_ProjectPriFullPathOriginal)</ProjectPriFullPath>
    </PropertyGroup>

  </Target>

  <!-- Calculate inputs for _GenerateProjectPriFileCore. -->
  <Target Name="_CalculateInputsForGenerateProjectPriFileCore">
    <ItemGroup>
      <_GenerateProjectPriFileCoreInput Include="$(_PriConfigXmlPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_LayoutResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_ResourcesResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="$(_PriResfilesPath)" />
      <_GenerateProjectPriFileCoreInput Include="@(PRIResource)" />
      <_GenerateProjectPriFileCoreInput Include="@(_PriFile)" />
      <_GenerateProjectPriFileCoreInput Include="@(SourceAppxManifest)" />
      <_GenerateProjectPriFileCoreInput Include="$(_EmbedFileResfilePath)" />
      <_GenerateProjectPriFileCoreInput Include="@(_EmbedFile)" />
      <_GenerateProjectPriFileCoreInput Include="@(_AdditionalResourceResFiles)" />
    </ItemGroup>
  </Target>

  <!-- Generates intermediate PRI file for the current project. -->
  <Target Name="_GenerateProjectPriFileCore"
          Inputs="$(MSBuildAllProjects);@(_GenerateProjectPriFileCoreInput)"
          Outputs="$(ProjectPriFullPath)"
            >

    <MakeDir Condition="'$(InsertReverseMap)' == 'true'"
             Directories="$(_ReverseMapProjectPriDirectory)"
                 />

    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)"
                            MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                            PriConfigXmlPath="$(_PriConfigXmlPath)"
                            IndexFilesForQualifiersCollection="$(_LayoutResfilesPath);$(_ResourcesResfilesPath)"
                            ProjectPriIndexName="$(ProjectPriIndexName)"
                            InsertReverseMap="$(InsertReverseMap)"
                            ProjectDirectory="$(ProjectDir)"
                            OutputFileName="$(ProjectPriFullPath)"
                            QualifiersPath="$(_QualifiersPath)"
                            IntermediateExtension="$(AppxIntermediateExtension)"
                            AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                            MultipleQualifiersPerDimensionFoundPath="$(_MultipleQualifiersPerDimensionFoundPath)"
                            AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)"
                                />

    <Message Text="$(MSBuildProjectName) -> $(ProjectPriFileName)" />

  </Target>

  <!-- Add FileReads and FileWrites done during generation of project PRI file. -->
  <Target Name="_AddFileReadsAndFileWritesForProjectPri">

    <ItemGroup>
      <FileReads Include="@(_GenerateProjectPriFileCoreInput)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="$(_PriConfigXmlPath)" />
      <FileWrites Include="$(_PriConfigXmlPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_LayoutResfilesPath)" />
      <FileWrites Include="$(_LayoutResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_ResourcesResfilesPath)" />
      <FileWrites Include="$(_ResourcesResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_PriResfilesPath)" />
      <FileWrites Include="$(_PriResfilesPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(ProjectPriFullPath)" />
      <FileWrites Include="$(_QualifiersPath)" />
      <FileWrites Include="$(_QualifiersPath)$(AppxIntermediateExtension)" />
      <FileWrites Include="$(_MultipleQualifiersPerDimensionFoundPath)" />
      <FileWrites Include="@(_AdditionalResourceResFiles)" />
      <FileWrites Include="@(_AdditionalResourceResFiles->'%(Identity)$(AppxIntermediateExtension)')" />
    </ItemGroup>

  </Target>

  <!--Create ProjectPriFile item. -->
  <Target Name="_CreateProjectPriFileItem"
          Condition="'$(AppxPackage)' == 'true'"
            >

    <ItemGroup>
      <ProjectPriFile Remove="@(ProjectPriFile)" />
      <ProjectPriFile Include="$(ProjectPriFullPath)">
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriFile>
    </ItemGroup>

    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <OsVersion>$(registry:HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion@CurrentVersion)</OsVersion>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <AppxUseResourceIndexerApi Condition="'$(OsVersion)' &lt; '6.3'">false</AppxUseResourceIndexerApi>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUseResourceIndexerApi)' == ''">
      <AppxUseResourceIndexerApi>true</AppxUseResourceIndexerApi>
    </PropertyGroup>

    <Message Importance="low" Text="AppxUseResourceIndexerApi=$(AppxUseResourceIndexerApi)" />

  </Target>

  <!-- Expand content of project PRI file. -->
  <Target Name="_ExpandProjectPriFile"
          Condition="'$(AppxPackage)' == 'true' and '$(AppxUseResourceIndexerApi)' == 'false'">

    <ExpandPriContent Inputs="@(ProjectPriFile)"
                      MakePriExeFullPath="$(MakePriExeFullPath)"
                      MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                      IntermediateDirectory="$(IntermediateOutputPath)"
                      AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)"
                          >
      <Output TaskParameter="Expanded" ItemName="IndexedPayloadFiles" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>

  </Target>

  <!-- Expand content of project PRI file. -->
  <Target Name="_ExpandMainPriFile">

    <ExpandPriContent Inputs="$(AppxBundleSplitResourcesPriPath)"
                      MakePriExeFullPath="$(MakePriExeFullPath)"
                      MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                      IntermediateDirectory="$(IntermediateOutputPath)"
                      AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)"
                          >
      <Output TaskParameter="Expanded" ItemName="IndexedMainPayloadFiles" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>

  </Target>

  <!-- Expand content of PRI files. -->
  <Target Name="_ExpandPriFiles">

    <ItemGroup>
      <_PriFilesToExpand Include="@(_PriFilesFromPayload)"
                         Condition="'%(OutputGroup)' != 'ProjectPriFile'
                                      and '%(OutputGroup)' != 'SDKRedistOutputGroup'"
                               />
    </ItemGroup>

    <ExpandPriContent Inputs="@(_PriFilesToExpand)"
                      MakePriExeFullPath="$(MakePriExeFullPath)"
                      MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                      IntermediateDirectory="$(IntermediateOutputPath)"
                      AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)"
                          >
      <Output TaskParameter="Expanded" ItemName="_ExpandedPriPayload" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>

  </Target>

  <!-- Expand content of PRI files. -->
  <Target Name="_ExpandPriUploadFiles"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_PriUploadFilesToExpand Include="@(_PriFilesFromPayload)"
                               Condition="'%(OutputGroup)' != 'ProjectPriUploadFile'
                                      and '%(OutputGroup)' != 'ProjectPriFile'
                                      and '%(OutputGroup)' != 'SDKRedistOutputGroup'"
                               />
    </ItemGroup>

    <ExpandPriContent Inputs="@(_PriUploadFilesToExpand)"
                      MakePriExeFullPath="$(MakePriExeFullPath)"
                      MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                      IntermediateDirectory="$(IntermediateOutputPath)"
                      AdditionalMakepriExeParameters="$(AppxExpandPriContentAdditionalMakepriExeParameters)"
                          >
      <Output TaskParameter="Expanded" ItemName="_ExpandedPriUploadPayload" />
      <Output TaskParameter="IntermediateFileWrites" ItemName="FileWrites" />
    </ExpandPriContent>

  </Target>

  <!-- Override to specify actions to happen after generating project PRI file. -->
  <Target Name="AfterGenerateProjectPriFile" />

  <PropertyGroup>
    <_ProjectArchitecturesFilePath>$(IntermediateOutputPath)ProjectArchitectures.txt</_ProjectArchitecturesFilePath>
  </PropertyGroup>

  <!-- Add Union winmd to payload if Appx contains managed component to make JITer happy -->
  <Target Name="_AddUnionWinmd" Condition="'$(AppxPackage)' == 'true' AND '$(TargetPlatformIdentifier)' == 'UAP'">

    <ItemGroup>
      <_PackagingOutputWinmd Include="@(PackagingOutputs)" Condition="'%(PackagingOutputs.Extension)' == '.winmd'" />
    </ItemGroup>

    <GetUnionWinmdPropertyValues TargetFrameworkIdentifier="$(TargetFrameworkIdentifier)"
                                 WinmdFiles="@(_PackagingOutputWinmd)">
      <Output TaskParameter="UnionWinmdRequired" PropertyName="_UnionWinmdRequired" />
    </GetUnionWinmdPropertyValues>

    <GetSdkPropertyValue TargetPlatformSdkRootOverride="$(TargetPlatformSdkRootOverride)"
                         SDKIdentifier="$(SDKIdentifier)"
                         SDKVersion="$(SDKVersion)"
                         TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                         TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                         TargetPlatformVersion="$(TargetPlatformVersion)"
                         PropertyName="WindowsSDK_UnionMetadataPath">
      <Output TaskParameter="PropertyValue" PropertyName="_UnionMetadataPath" />
    </GetSdkPropertyValue>

    <ItemGroup>
      <UnionWinmdPath Condition="'$(_UnionMetadataPath)' == ''" Include="$(_TargetPlatformSdkDir)UnionMetadata\Windows.winmd"/>
      <UnionWinmdPath Condition="'$(_UnionMetadataPath)' != ''" Include="$(_UnionMetadataPath)\Windows.winmd"/>

      <UnionMetadataWinmd Include="@(UnionWinmdPath)" Condition="Exists(@(UnionWinmdPath)) AND 
                              ('IncludeWindowsSdkWinmd' == 'true' OR '$(_UnionWinmdRequired)' == 'true')">
        <ResolvedFrom>GetSDKReferenceFiles</ResolvedFrom>
        <SkipHarvestingWinmdRegistration>true</SkipHarvestingWinmdRegistration>
        <TargetPath>$(WinMetadataDir)\Windows.winmd</TargetPath>
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </UnionMetadataWinmd>

      <PackagingOutputs Include="@(UnionMetadataWinmd)" />
    </ItemGroup>

    <Message Condition="'$(_UnionWinmdRequired)' == 'true'" Text="$(MSBuildProjectName) -> @(UnionWinmdPath)" />
  </Target>

  <!-- Add referenced winmds from Framework SDKs -->
  <Target Name="_AddFxWinmd"
          Condition="'$(AppxPackage)' == 'true' AND 
                     '$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_FrameworkSdkReference Include="@(ResolvedSDKReference)" Condition=" '%(ResolvedSDKReference.FrameworkIdentity)' != '' " />
    </ItemGroup>

    <PropertyGroup>
      <_FrameworkSdkNames>@(_FrameworkSdkReference->'%(SDKName)', ';')</_FrameworkSdkNames>
    </PropertyGroup>

    <ItemGroup>
      <WinmdsFromFrameworkSDKs Include="@(ReferencesFromSDK)"
                               Condition="$(_FrameworkSdkNames.Contains('%(ReferencesFromSDK.ReferenceFromSDK)')) and
                                          '%(ReferencesFromSDK.WinMDFile)'=='true'" >
        <SkipHarvestingWinmdRegistration>true</SkipHarvestingWinmdRegistration>
        <TargetPath>$(WinMetadataDir)\$([System.IO.Path]::GetFileName(%(ReferencesFromSDK.Identity)))</TargetPath>
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </WinmdsFromFrameworkSDKs>
      <PackagingOutputs Include="@(WinmdsFromFrameworkSDKs)" />
    </ItemGroup>
  </Target>

  <!-- =================================================================================================== -->
  <!-- Computes the AppxUpload creation flag for UAP if the user did not specify a UapAppxPackageBuildMode -->
  <!-- =================================================================================================== -->
  <Target Name="_ComputeBuildAppxUploadPackageForUapFlag"
          DependsOnTargets="_FindStoreAssociationFile">

    <!-- When buildling from the commandline, if the BuildMode is NOT set but an AppxUpload package is requested, we have to make a couple extra checks -->
    <PropertyGroup Condition="'$(BuildingInsideVisualStudio)' != 'true' and
                              '$(UapAppxPackageBuildModeIsValid)' == 'false' and
                              '$(BuildAppxUploadPackageForUap)' != ''">

      <!-- First, we assume that this flow should NOT be creating an .appxupload package -->
      <BuildAppxUploadPackageForUap>false</BuildAppxUploadPackageForUap>

      <!-- If we are here, the build mode was NOT explicitly set. So, only produce an .appxupload if:
        - we are in the UAP pipeline
        - AND the .NetNative toolchain is not disabled (doing a negative check as non .net platforms may leave this value blank)
        - AND the project configuration is not Debug (doing a negative check to avoid ruling out custom build configurations)
        - AND the store association file exists
      -->
      <BuildAppxUploadPackageForUap Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)' and
                                               '$(UseDotNetNativeToolchain)' != 'false' and
                                               '$(Configuration)' != 'Debug' and
                                               '%(StoreAssociationFile.Identity)' != ''">true</BuildAppxUploadPackageForUap>
    </PropertyGroup>

  </Target>

  <!-- ================================================================================================== -->
  <!-- Computes Appx package payload that will be included in the appx package (excluding Appx manifest). -->
  <!-- ================================================================================================== -->
  <Target Name="_ComputeAppxPackagePayload"
          Condition="'$(AppxPackage)' == 'true'"
          DependsOnTargets="_FindSourceAppxContentGroupMap">

    <ItemGroup>
      <_UnfilteredAppxPackagePayload Include="@(PackagingOutputs)" Condition="'%(Extension)' != '.pri' AND 
                                                                              '%(OutputGroup)' != 'GetResolvedSDKReferences' AND 
                                                                              '%(OutputGroup)' != '_GetProjectArchitecture' AND 
                                                                              '%(OutputGroup)' != 'EmbedOutputGroupForPackaging'"/>
      <_UnfilteredAppxPackagePayload Include="@(_ExpandedPriPayload)" />
      <_UnfilteredAppxPackagePayload Include="@(ProjectPriFile)" />
    </ItemGroup>

    <!-- Users can manually populate the AppxPackagePayload. In the .NetNative case, this is handled by ILC. Otherwise, we need to retain those files -->
    <ItemGroup Condition="'$(UseDotNetNativeToolchain)' != 'true'">

      <!-- If the user added a payload with a rooted path, we can safely use that -->
      <_UnfilteredAppxPackagePayload Condition="$([System.IO.Path]::IsPathRooted('%(Identity)')) == 'true'"
                                     Include="@(AppxPackagePayload->'%(Identity)')">
        <TargetPath>$([System.String]::Copy('%(TargetPath)').Replace('\\','\'))</TargetPath>
      </_UnfilteredAppxPackagePayload>

      <!-- If the user added a payload with a relative path, we make the assumption that it's relative to the project root and build out the full path -->
      <_UnfilteredAppxPackagePayload Condition="$([System.IO.Path]::IsPathRooted('%(Identity)')) == 'false'"
                                     Include="@(AppxPackagePayload->'$(MSBuildProjectDirectory)\%(Identity)')">
        <TargetPath>$([System.String]::Copy('%(TargetPath)').Replace('\\','\'))</TargetPath>
      </_UnfilteredAppxPackagePayload>

      <!-- Reset the AppxPackagePayload to avoid duplicate entries later -->
      <AppxPackagePayload Remove="@(AppxPackagePayload)"/>
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_UnfilteredAppxUploadPackagePayload Include="@(PackagingOutputs)" Condition="'%(Extension)' != '.pri' AND 
                                                                                    '%(OutputGroup)' != 'GetResolvedSDKReferences' AND 
                                                                                    '%(OutputGroup)' != '_GetProjectArchitecture' AND 
                                                                                    '%(OutputGroup)' != 'EmbedOutputGroupForPackaging'"/>
      <_UnfilteredAppxUploadPackagePayload Include="@(_ExpandedPriUploadPayload)" />
      <_UnfilteredAppxUploadPackagePayload Include="@(ProjectPriUploadFile)" />
    </ItemGroup>

    <RemovePayloadDuplicates Inputs="@(_UnfilteredAppxPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="AppxPackagePayload" />
    </RemovePayloadDuplicates>

    <RemovePayloadDuplicates Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
                             Inputs="@(_UnfilteredAppxUploadPackagePayload)"
                             HasSharedItems="$(HasSharedItems)"
                             MSBuildProjectDirectory="$(MSBuildProjectDirectory)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="DeDupedAppxUploadPackagePayload" />
    </RemovePayloadDuplicates>

    <!-- 
        If packaging outputs contain a file named AppxManifest.xml, this is an override manifest and it is handled elsewhere.
        If packaging outputs contain the store association file, we need to remove it. Furthermore,
        we need to remove the SourceAppxContentGroupMap file, or if producing an Appx Bundle, the AppxContentGroupMap as well.
    -->
    <ItemGroup>
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(TargetPath)' == '$(AppxManifestFileName)'" />
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(TargetPath)' == 'Package.StoreAssociation.xml'"/>
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(TargetPath)' == 'SourceAppxContentGroupMap.xml'"/>
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="$(ProduceAppxBundle) == 'true' AND '%(TargetPath)' == 'AppxContentGroupMap.xml'"/>
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <DeDupedAppxUploadPackagePayload Remove="@(DeDupedAppxUploadPackagePayload)" Condition="'%(TargetPath)' == '$(AppxManifestFileName)'" />
    </ItemGroup>

    <!-- If we are NOT going through the .Net Native toolchain, this generated payload becomes the payload we'll package for upload -->
    <ItemGroup Condition="'$(UseDotNetNativeToolchain)' != 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxUploadPackagePayload Include="@(DeDupedAppxUploadPackagePayload)"/>
    </ItemGroup>

    <!-- If the Upload packaging outputs contain the store association file, the SourceAppxContentGroupMap file, 
         or if producing an Appx Bundle, the AppxContentGroupMap, we need to remove it -->
    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(TargetPath)' == 'Package.StoreAssociation.xml'"/>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(TargetPath)' == 'SourceAppxContentGroupMap.xml'"/>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="$(ProduceAppxBundle) == 'true' AND '%(TargetPath)' == 'AppxContentGroupMap.xml'"/>
    </ItemGroup>

    <ItemGroup>
      <_ProjectArchitectureFromPayload Include="@(PackagingOutputs)"
                                       Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture'
                                                    AND '%(PackagingOutputs.MSBuildSourceProjectFile)' != ''"
                                             />
      <_ProjectArchitectureFromPayload Include="@(PackagingOutputs)"
                                       Condition="'%(PackagingOutputs.OutputGroup)' == '_GetProjectArchitecture'
                                                    AND '%(PackagingOutputs.MSBuildSourceProjectFile)' == ''"
                                             >
        <MSBuildSourceProjectFile>$(MSBuildProjectFullPath)</MSBuildSourceProjectFile>
      </_ProjectArchitectureFromPayload>
    </ItemGroup>

    <GenerateProjectArchitecturesFile
        ProjectArchitectures="@(_ProjectArchitectureFromPayload)"
        ProjectArchitecturesFilePath="$(_ProjectArchitecturesFilePath)"
            />

    <ItemGroup>
      <FileWrites Include="$(_ProjectArchitecturesFilePath)" />
    </ItemGroup>

  </Target>

  <!-- ==================================================================================== -->
  <!-- Generating Appx manifest.                                                            -->
  <!-- Happens after generating PRI file, for every project which can be packaged/deployed. -->
  <!-- ==================================================================================== -->

  <PropertyGroup>
    <_GenerateAppxManifestDependsOn>
      $(_GenerateAppxManifestDependsOn);
      BeforeGenerateAppxManifest;
      _GenerateAdditionalFrameworkSDKReference;
      _GetRecursiveResolvedSDKReferences;
      _CopyCurrentProjectAppxManifestOverride;
      _CopyCurrentProjectAppxUploadManifestOverride;
      _CalculateInputsForGenerateCurrentProjectAppxManifest;
      _GenerateCurrentProjectAppxManifest;
      _CreateFinalAppxManifestItem;
      _FindStoreAssociationFile;
      _ValidateAppxManifest;
      _CopyProjectAppxManifestToAppxUpload;
      AfterGenerateAppxManifest
    </_GenerateAppxManifestDependsOn>
  </PropertyGroup>

  <Target Name="_GenerateAdditionalFrameworkSDKReference">

    <ItemGroup>
      <_IntermediateFrameworkSdkReference
        Include="@(AppxPackageRegistration)"
        Condition="'@(AppxPackageRegistration)' != '' 
                   AND ('$(Configuration)' == '%(AppxPackageRegistration.Configuration)' OR '%(AppxPackageRegistration.Configuration)' == '') 
                   AND ('$(Platform)' == '%(AppxPackageRegistration.Architecture)' OR '%(AppxPackageRegistration.Configuration)' == '')">
        <SDKName Condition="%(AppxPackageRegistration.Name) != ''">%(AppxPackageRegistration.Name)</SDKName>
        <SDKName Condition="%(AppxPackageRegistration.Name) == ''">%(AppxPackageRegistration.Filename)</SDKName>
        <TargetedSDKConfiguration>%(AppxPackageRegistration.Configuration)</TargetedSDKConfiguration>
        <TargetedSDKArchitecture>%(AppxPackageRegistration.Architecture)</TargetedSDKArchitecture>
        <AppxLocation>%(AppxPackageRegistration.Identity)</AppxLocation>       
      </_IntermediateFrameworkSdkReference>

      <FrameworkSdkReference Include="@(_IntermediateFrameworkSdkReference)">
        <FrameworkIdentity>Name = %(_IntermediateFrameworkSdkReference.SDKName), MinVersion = %(_IntermediateFrameworkSdkReference.Version), Publisher = %(_IntermediateFrameworkSdkReference.Publisher)</FrameworkIdentity>
      </FrameworkSdkReference>
    </ItemGroup>

  </Target>

  <Target Name="_GenerateAppxManifest"
          Condition="'$(AppxPackage)' == 'true'"
          DependsOnTargets="$(_GenerateAppxManifestDependsOn)"
            />

  <!-- Override to specify actions to happen before generating Appx manifest. -->
  <Target Name="BeforeGenerateAppxManifest" />

  <!-- Extract SDK references from the payload and filters out duplicates. -->
  <Target Name="_GetRecursiveResolvedSDKReferences">

    <ItemGroup>
      <_UnfilteredRecursiveResolvedSDKReference Include="@(PackagingOutputs)"
                                                Condition="'%(OutputGroup)' == 'GetResolvedSDKReferences'" />
    </ItemGroup>

    <RemoveDuplicateSDKReferences Inputs="@(_UnfilteredRecursiveResolvedSDKReference)">
      <Output TaskParameter="Filtered" ItemName="RecursiveResolvedSDKReference" />
    </RemoveDuplicateSDKReferences>

    <ItemGroup>
      <FrameworkSdkReference Include="@(RecursiveResolvedSDKReference)"
                             Condition="'%(RecursiveResolvedSDKReference.FrameworkIdentity)' != ''"
                             />
    </ItemGroup>

    <ItemGroup>
      <NonFrameworkSdkReference Include="@(RecursiveResolvedSDKReference)"
                                Condition="'%(RecursiveResolvedSDKReference.FrameworkIdentity)' == ''"
                                />
    </ItemGroup>

    <!-- Add non-framework SDK versions to manifest build metadata. -->
    <ItemGroup>
      <AppxManifestMetadata Include="@(NonFrameworkSdkReference)">
        <Name>%(NonFrameworkSdkReference.SimpleName)</Name>
        <Version>%(NonFrameworkSdkReference.Version)</Version>
      </AppxManifestMetadata>
    </ItemGroup>

    <GetFrameworkSdkPackages FrameworkSdkReferences="@(FrameworkSdkReference)"
                             TargetPlatformIdentifier="$(TargetPlatformIdentifier)">
      <Output TaskParameter="FrameworkSdkPackages" ItemName="FrameworkSdkPackage" />
    </GetFrameworkSdkPackages>

  </Target>

  <!-- Copy overriden AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyCurrentProjectAppxManifestOverride"
          Condition="Exists(@(CustomAppxManifest))"
          Inputs="$(MSBuildAllProjects);@(CustomAppxManifest)"
          Outputs="$(FinalAppxManifestName)">

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(CustomAppxManifest)"
          DestinationFiles="$(FinalAppxManifestName)"
              />

  </Target>

  <!-- Copy overriden upload AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxUploadManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyCurrentProjectAppxUploadManifestOverride"
          Condition="Exists(@(CustomAppxManifest)) and '$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(CustomAppxManifest)"
          Outputs="$(FinalAppxUploadManifestName)">

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(CustomAppxManifest)"
          DestinationFiles="$(FinalAppxUploadManifestName)"/>

  </Target>

  <!-- Calculates list of input for _GenerateCurrentProjectAppxManifest target. -->
  <Target Name="_CalculateInputsForGenerateCurrentProjectAppxManifest">

    <ItemGroup Condition="'$(AppxHarvestWinmdRegistration)' == 'true'">
      <_WinmdFilesFromWinmdArtifacts Include="@(PackagingOutputs)"
                                     Condition="'%(PackagingOutputs.Extension)' == '.winmd' 
                                            and '%(PackagingOutputs.OutputGroup)' == 'CopyWinmdArtifactsOutputGroup'
                                            and '%(PackagingOutputs.ProjectName)' != '$(ProjectName)'
                                            and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'"/>
      <_WinmdFilesFromReferences Include="@(PackagingOutputs)"
                                 Condition="'%(PackagingOutputs.Extension)' == '.winmd' 
                                        and '%(PackagingOutputs.OutputGroup)' == 'CopyLocalFilesOutputGroup'
                                        and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromOtherGroups Include="@(PackagingOutputs)"
                                  Condition="'%(PackagingOutputs.Extension)' == '.winmd' 
                                         and '%(PackagingOutputs.OutputGroup)' != 'CopyWinmdArtifactsOutputGroup'
                                         and '%(PackagingOutputs.OutputGroup)' != 'CopyLocalFilesOutputGroup'
                                         and '%(PackagingOutputs.ResolvedFrom)' != 'GetSDKReferenceFiles'
                                         and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
      <_WinmdFilesFromSDKs Include="@(PackagingOutputs)"
                           Condition="'%(PackagingOutputs.Extension)' == '.winmd'
                                  and '%(PackagingOutputs.ResolvedFrom)' == 'GetSDKReferenceFiles'
                                  and '%(PackagingOutputs.SkipHarvestingWinmdRegistration)' != 'true'" />
    </ItemGroup>

    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromWinmdArtifacts)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>

    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromReferences)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>

    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromOtherGroups)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_AppxWinmdFilesToHarvest" />
    </RemovePayloadDuplicates>

    <RemovePayloadDuplicates Inputs="@(_WinmdFilesFromSDKs)"
                             ProjectName="$(ProjectName)"
                             Platform="$(Platform)">
      <Output TaskParameter="Filtered" ItemName="_AppxSDKWinmdFilesForHarvest" />
    </RemovePayloadDuplicates>


    <ItemGroup>
      <_GenerateCurrentProjectAppxManifestInput Include="@(AppxManifest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(AppxManifestSchema)" />
      <_GenerateCurrentProjectAppxManifestInput Include="$(PackageCertificateKeyFile)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(_AppxWinmdFilesToHarvest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="@(_AppxSDKWinmdFilesForHarvest)" />
      <_GenerateCurrentProjectAppxManifestInput Include="$(_QualifiersPath)" />
    </ItemGroup>

  </Target>

  <!-- Generates a final AppxManifest.xml that will be included in the appx package. -->
  <!-- The generation includes pre-processing of any tokens in the input manifest file to produce a valid appx manifest file. -->
  <!-- Input: [AppxManifest] Name of the manifest file template. -->
  <!-- Output: [FinalAppxManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_GenerateCurrentProjectAppxManifest"
          Condition="Exists(@(AppxManifest))"
          Inputs="$(MSBuildAllProjects);@(_GenerateCurrentProjectAppxManifestInput)"
          Outputs="$(FinalAppxManifestName)">

    <ItemGroup>
      <AppxManifestMetadata Include="$(MakePriExeFullPath)" />
    </ItemGroup>

    <GenerateAppxManifest AppxManifestInput="@(AppxManifest)"
                          AppxManifestOutput="$(FinalAppxManifestName)"
                          ApplicationExecutableName="$(TargetName)"
                          FrameworkSdkReferences="@(FrameworkSdkReference)"
                          NonFrameworkSdkReferences="@(NonFrameworkSdkReference)"
                          CertificateThumbprint="$(PackageCertificateThumbprint)"
                          CertificateFile="$(PackageCertificateKeyFile)"
                          DefaultResourceLanguage="$(DefaultResourceLanguage)"
                          QualifiersPath="$(_QualifiersPath)"
                          PackageArchitecture="$(PackageArchitecture)"
                          SDKWinmdFiles="@(_AppxSDKWinmdFilesForHarvest)"
                          WinmdFiles="@(_AppxWinmdFilesToHarvest)"
                          ManagedWinmdInprocImplementation="$(ManagedWinmdInprocImplementation)"
                          OSMinVersion="$(AppxOSMinVersion)"
                          OSMaxVersionTested="$(AppxOSMaxVersionTested)"
                          OSMinVersionReplaceManifestVersion="$(AppxOSMinVersionReplaceManifestVersion)"
                          OSMaxVersionTestedReplaceManifestVersion="$(AppxOSMaxVersionTestedReplaceManifestVersion)"
                          PackageSigningEnabled="$(AppxPackageSigningEnabled)"
                          EnableSigningChecks="$(EnableSigningChecks)"
                          ManifestMetadata="@(AppxManifestMetadata)"
                          MetadataNamespaceUri="$(MetadataNamespaceUri)"
                          TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                          TargetPlatformMinVersion="$(TargetPlatformMinVersion)"
                          TargetPlatformVersion="$(TargetPlatformVersion)"
                              />

    <ItemGroup>
      <AllGeneratedManifests Include="$(FinalAppxManifestName)" />
    </ItemGroup>

    <Message Importance="low" Text="@(AppxManifest) -> $(FinalAppxManifestName)" />

  </Target>

  <!-- In order for incremental build and clean to work correctly,       -->
  <!-- we are creating build item @(FinalAppxManifest) and @(FileWrites) -->
  <!-- in the target which always executes.                              -->
  <Target Name="_CreateFinalAppxManifestItem">

    <ItemGroup>
      <FinalAppxManifest Include="$(FinalAppxManifestName)" />
    </ItemGroup>

    <ItemGroup>
      <FileReads Include="@(CustomAppxManifest)"/>
      <FileReads Include="@(_GenerateCurrentProjectAppxManifestInput)"/>
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="@(FinalAppxManifest)"/>
    </ItemGroup>

  </Target>

  <!-- Copy overriden upload AppxManifest.xml to final location. -->
  <!-- Inputs: [CustomAppxManifest] Name of the manifest file override. -->
  <!-- Outputs: [FinalAppxUploadManifest] Final manifest file which will be included in the appx package. -->
  <Target Name="_CopyProjectAppxManifestToAppxUpload"
          Condition="'$(UseDotNetNativeToolchain)' != 'true' and
                     '$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);"
          Outputs="$(FinalAppxUploadManifestName)">

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SourceFiles="@(FinalAppxManifest)"
          DestinationFiles="$(FinalAppxUploadManifestName)"/>

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SourceFiles="@(ProjectPriFile)"
          DestinationFiles="$(ProjectPriUploadFullPath)"/>

    <ItemGroup>
      <FinalAppxUploadManifest Include="$(FinalAppxUploadManifestName)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="@(FinalAppxUploadManifest)"/>
    </ItemGroup>

  </Target>

  <!-- Finds store association file. -->
  <Target Name="_FindStoreAssociationFile">

    <ItemGroup Condition="'@(StoreAssociationFile)' == ''">
      <StoreAssociationFile Include="@(None)" Condition="'%(Identity)' == 'Package.StoreAssociation.xml'" />
      <None Remove="@(None)" Condition="'%(Identity)' == 'Package.StoreAssociation.xml'" />
    </ItemGroup>

  </Target>

  <!-- Finds and validates the bundle mapping file. -->
  <Target Name="_FindAndValidateBundleMappingFile">

    <ItemGroup Condition="'@(BundleMappingFile)' == ''">
      <BundleMappingFile Include="@(BundleMapping)" Condition="'%(Identity)' == 'Bundle.Mapping.txt'" />
      <BundleMappingFile Include="@(Content)" Condition="'%(Identity)' == 'Bundle.Mapping.txt' and '$(BundleMappingFile)' == ''" />
      <BundleMappingFile Include="@(Text)" Condition="'%(Identity)' == 'Bundle.Mapping.txt' and '$(BundleMappingFile)' == ''" />
      <None Remove="@(BundleMapping)" Condition="'%(Identity)' == 'Bundle.Mapping.txt'" />
    </ItemGroup>

    <ValidateBundleMapping Condition="'@(BundleMappingFile)' != ''" Input="@(BundleMappingFile)">
      <Output TaskParameter="ExternalPackages" ItemName="_BundleMappingExternalPackages"/>
      <Output TaskParameter="OptionalProjects" ItemName="_BundleMappingOptionalProjects"/>
    </ValidateBundleMapping>

  </Target>


  <!-- Validates final Appx manifest. -->
  <Target Name="_ValidateAppxManifest">

    <ValidateAppxManifest Input="@(FinalAppxManifest)"
                      SourceAppxManifest="@(SourceAppxManifest)"
                      AppxManifestSchema="@(AppxManifestSchema)"
                      StoreAssociationFile="@(StoreAssociationFile)"
                      TargetPlatformVersion="$(TargetPlatformVersion)"
                      TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                      OSMinVersion="$(AppxOSMinVersion)"
                      OSMaxVersionTested="$(AppxOSMaxVersionTested)"
                      PlatformVersionDescriptions="@(PlatformVersionDescription)"
                      ResolvedSDKReferences="@(RecursiveResolvedSDKReference)"
                      ValidateWinmds="$(_CustomAppxManifestUsed)"
                      StrictManifestValidationEnabled="$(AppxStrictManifestValidationEnabled)"
                      WinmdFiles="@(_AppxWinmdFilesToHarvest)"
                      SDKWinmdFiles="@(_AppxSDKWinmdFilesForHarvest)"
                      NonFrameworkSdkReferences="@(NonFrameworkSdkReference)"
                      ManagedWinmdInprocImplementation="$(ManagedWinmdInprocImplementation)"
                      ValidateManifest="$(AppxValidateAppxManifest)"
                      AppxPackagingComponentManifestPath="$(AppxPackagingComponentManifestPath)"
                      FrameworkSdkPackages="@(FrameworkSdkPackage)"
                              >
      <Output TaskParameter="Resources" ItemName="_ManifestResources" />
    </ValidateAppxManifest>

  </Target>

  <!-- Override to specify actions to happen after generating Appx manifest. -->
  <Target Name="AfterGenerateAppxManifest" />

  <!-- Validates Store manifest if it exists. -->
  <Target Name="_ValidateStoreManifest"
          Condition="'$(AppxValidateStoreManifest)' == 'true' and Exists($(StoreManifestName))">

    <ValidateStoreManifest Input="$(StoreManifestName)"
                           StoreManifestSchema="@(StoreManifestSchema)" />

  </Target>

  <!-- ========================================================================================= -->
  <!-- Generating Appx package recipe.                                                           -->
  <!-- Happens after generating Appx manifest, for every project which can be packaged/deployed. -->
  <!-- ========================================================================================= -->

  <!-- Ensure Fast UpToDate check also consider the .appxrecipe file as an output -->
  <ItemGroup Condition="'$(AppxPackage)' == 'true'">
    <UpToDateCheckOutput Include="$(AppxPackageRecipe)" />
  </ItemGroup>

  <ItemGroup Condition="'$(AppxPackage)' == 'true' and '$(BuildAppxUploadPackageForUap)' == 'true'">
    <UpToDateCheckOutput Include="$(AppxUploadPackageRecipe)" />
  </ItemGroup>

  <PropertyGroup>
    <_GenerateAppxPackageRecipeDependsOn>
      BeforeGenerateAppxPackageRecipe;
      $(_GenerateAppxPackageRecipeDependsOn);
      _CalculateInputsForGenerateAppxPackageRecipe;
      _GenerateAppxPackageRecipeFile;
      _FileReadsAndWritesForGenerateAppxPackageRecipe
    </_GenerateAppxPackageRecipeDependsOn>
  </PropertyGroup>

  <PropertyGroup>
    <_GenerateAppxUploadPackageRecipeDependsOn>
      BeforeGenerateAppxPackageRecipe;
      $(_GenerateAppxUploadPackageRecipeDependsOn);
      _CalculateInputsForGenerateAppxUploadPackageRecipe;
      _GenerateAppxUploadPackageRecipeFile;
      _FileReadsAndWritesForGenerateAppxUploadPackageRecipe
    </_GenerateAppxUploadPackageRecipeDependsOn>
  </PropertyGroup>

  <!-- Override to specify actions to happen before generating Appx manifest. -->
  <Target Name="BeforeGenerateAppxPackageRecipe"/>

  <Target Name="_GenerateAppxPackageRecipe"
          Condition="'$(AppxPackage)' == 'true' and 
                     '$(AppxGeneratePackageRecipeEnabled)' == 'true'"
          DependsOnTargets="$(_GenerateAppxPackageRecipeDependsOn)"
          />

  <Target Name="_GenerateAppxUploadPackageRecipe"
          Condition="'$(AppxPackage)' == 'true' and 
                     '$(AppxGeneratePackageRecipeEnabled)' == 'true' and 
                     '$(BuildAppxUploadPackageForUap)' == 'true'"
          DependsOnTargets="$(_GenerateAppxUploadPackageRecipeDependsOn)"
          />

  <!-- Creates the recipe file for the the appx package -->
  <Target Name="_CalculateInputsForGenerateAppxPackageRecipe">

    <ItemGroup>
      <_GenerateAppxPackageRecipeInput Include="@(FinalAppxManifest)" />
      <_GenerateAppxPackageRecipeInput Include="@(AppxPackagePayload)" />
      <_GenerateAppxPackageRecipeInput Include="$(_ProjectArchitecturesFilePath)" />
      <_GenerateAppxPackageRecipeInput Include="$(MSBuildProjectFullPath).user" Condition="Exists('$(MSBuildProjectFullPath).user')" />
    </ItemGroup>

    <ItemGroup>
      <PDBPayload Include="@(AppxPackagePayload)" Condition="'%(Extension)'=='.pdb'" />
    </ItemGroup>

    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

    <ItemGroup>
      <AdditionalReRegisterAppIfChangedTargetPaths Include="%(ProjectPriFile.TargetPath)" />
    </ItemGroup>

  </Target>

  <!-- Creates the recipe file for the the appx upload package -->
  <Target Name="_CalculateInputsForGenerateAppxUploadPackageRecipe">

    <ItemGroup>
      <_GenerateAppxUploadPackageRecipeInput Include="@(FinalAppxUploadManifest)" />
      <_GenerateAppxUploadPackageRecipeInput Include="@(AppxUploadPackagePayload)" />
      <_GenerateAppxUploadPackageRecipeInput Include="$(_ProjectArchitecturesFilePath)" />
    </ItemGroup>

    <ItemGroup>
      <PDBUploadPayload Include="@(AppxUploadPackagePayload)" Condition="'%(Extension)'=='.pdb'" />
    </ItemGroup>

    <!-- The uploaded .appx package should never include pdb's -->
    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

  </Target>

  <!-- Creates the recipe file for the the appx package -->
  <Target Name="_GenerateAppxPackageRecipeFile"
          Inputs="$(MSBuildAllProjects);@(_GenerateAppxPackageRecipeInput)"
          Outputs="$(AppxPackageRecipe)">

    <GenerateAppxPackageRecipe
        AppxManifestXml="%(FinalAppxManifest.FullPath)"
        AppxBundleManifestXml="$(FinalAppxBundleManifestName)"
        SourceAppxManifest="@(SourceAppxManifest)"
        SolutionConfiguration="$(Configuration)|$(Platform)"
        PayloadFiles="@(AppxPackagePayload)"
        FrameworkSdkPackages="@(FrameworkSdkPackage)"
        RecipeFile="$(AppxPackageRecipe)"
        SystemBinaries="@(AppxSystemBinary)"
        ReservedFileNames="@(AppxReservedFileName)"
        AppxManifestSchemas="@(AppxManifestSchema)"
        ManifestFileNameQueries="@(AppxManifestFileNameQuery)"
        ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)"
        AdditionalReRegisterAppIfChangedTargetPaths="@(AdditionalReRegisterAppIfChangedTargetPaths)"
        PackageArchitecture="$(PackageArchitecture)"
        ProjectDir="$(ProjectDir)"
        IntermediateOutputPath="$(IntermediateOutputPath)"
        MakePriExtensionPath="$(InProcessMakePriExtensionPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformVersion)"
        PlatformVersionDescriptions="@(PlatformVersionDescription)"
        IndexedPayloadFiles="@(IndexedPayloadFiles)"
        MrmSupportLibraryPath="$(MrmSupportLibraryPath)"
        UseResourceIndexerApi="$(AppxUseResourceIndexerApi)"
        DisableAppxManifestItemPackageContentValidation="$(DisableAppxManifestItemPackageContentValidation)"
        RemoteDeploymentType="$(RemoteDeploymentType)"
        PackageRegistrationPath="$(PackageRegistrationPath)"
        RemoveNonLayoutFiles="$(RemoveNonLayoutFiles)"
        WindowsSdkPath="$(WindowsSdkPath)"
        LayoutDir="$(LayoutDir)"
        OptionalProjectRecipeFiles="@(BundleMappingRecipes)"
        DeployOptionalPackages="$(DeployOptionalPackages)"
        />

    <ItemGroup>
      <AllGeneratedRecipes Include="$(AppxPackageRecipe)" />
    </ItemGroup>

    <Message Importance="low" Text="Manifest: %(FinalAppxManifest.Identity)" />
    <Message Importance="low" Text="Payload: %(AppxPackagePayload.TargetPath) from %(AppxPackagePayload.FullPath)" />
    <Message Importance="low" Text="SDK reference: %(RecursiveResolvedSDKReference.TargetPath) from %(RecursiveResolvedSDKReference.FullPath)" />
    <Message Importance="low" Text="$(MSBuildProjectName) -> $(AppxPackageRecipe)" />

  </Target>

  <!-- Creates the recipe file for the the appx upload package -->
  <Target Name="_GenerateAppxUploadPackageRecipeFile"
          Inputs="$(MSBuildAllProjects);@(_GenerateAppxUploadPackageRecipeInput)"
          Outputs="$(AppxUploadPackageRecipe)">

    <!-- Make sure the target directory exists as GenerateAppxPackageRecipe won't create it -->
    <MakeDir Directories="$(TargetDir)$(AppxUploadPackageArtifactsDir)" />

    <GenerateAppxPackageRecipe
        AppxManifestXml="%(FinalAppxUploadManifest.FullPath)"
        AppxBundleManifestXml="$(FinalAppxBundleManifestName)"
        SourceAppxManifest="@(SourceAppxManifest)"
        SolutionConfiguration="$(Configuration)|$(Platform)"
        PayloadFiles="@(AppxUploadPackagePayload)"
        FrameworkSdkPackages="@(FrameworkSdkPackage)"
        RecipeFile="$(AppxUploadPackageRecipe)"
        SystemBinaries="@(AppxSystemBinary)"
        ReservedFileNames="@(AppxReservedFileName)"
        AppxManifestSchemas="@(AppxManifestSchema)"
        ManifestFileNameQueries=""
        ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)"
        PackageArchitecture="$(PackageArchitecture)"
        ProjectDir="$(ProjectDir)"
        IntermediateOutputPath="$(IntermediateOutputPath)"
        MakePriExtensionPath="$(InProcessMakePriExtensionPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformVersion)"
        PlatformVersionDescriptions="@(PlatformVersionDescription)"
        IndexedPayloadFiles="@(IndexedPayloadFiles)"
        MrmSupportLibraryPath="$(MrmSupportLibraryPath)"
        UseResourceIndexerApi="$(AppxUseResourceIndexerApi)"
        DisableAppxManifestItemPackageContentValidation="$(DisableAppxManifestItemPackageContentValidation)"
        RemoteDeploymentType="$(RemoteDeploymentType)"
        PackageRegistrationPath="$(PackageRegistrationPath)"
        RemoveNonLayoutFiles="$(RemoveNonLayoutFiles)"
        WindowsSdkPath="$(WindowsSdkPath)"
        LayoutDir="$(LayoutDir)"
        DeployOptionalPackages="$(DeployOptionalPackages)"
        />

    <Message Importance="low" Text="Manifest: %(FinalAppxUploadManifest.Identity)" />
    <Message Importance="low" Text="Payload: %(AppxUploadPackagePayload.TargetPath) from %(AppxUploadPackagePayload.FullPath)" />
    <Message Importance="low" Text="SDK reference: %(RecursiveResolvedSDKReference.TargetPath) from %(RecursiveResolvedSDKReference.FullPath)" />
    <Message Importance="low" Text="$(MSBuildProjectName) -> $(AppxUploadPackageRecipe)" />

  </Target>

  <!-- Add FileReads and FileWrites done during generation of package recipe file. -->
  <Target Name="_FileReadsAndWritesForGenerateAppxPackageRecipe">

    <ItemGroup>
      <FileReads Include="@(_GenerateAppxPackageRecipeInput)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="$(AppxPackageRecipe)"/>
    </ItemGroup>

  </Target>

  <!-- Add FileReads and FileWrites done during generation of upload package recipe file. -->
  <Target Name="_FileReadsAndWritesForGenerateAppxUploadPackageRecipe">

    <ItemGroup>
      <FileReads Include="@(_GenerateAppxUploadPackageRecipeInput)" />
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackageRecipe)"/>
    </ItemGroup>

  </Target>

  <!-- ==================================================================================== -->
  <!-- Creates a .tlog file from the FileReads items so that up-to-date check works in C++. -->
  <!-- ==================================================================================== -->
  <Target Name="_AppendToReadTlogFile"
          Condition="'$(Language)' == 'C++' and '@(FileReads)' != ''">

    <ItemGroup>
      <_FileReadsWithoutPDBs Include="@(FileReads)" Condition="%(Extension) != '.pdb'" />
    </ItemGroup>

    <WriteLinesToFile
        File="$(TLogLocation)$(ProjectName).read.1u.tlog"
        Lines="^$(ProjectPath);@(_FileReadsWithoutPDBs-&gt;'%(Fullpath)')"
        Encoding="Unicode" />
  </Target>

  <!-- ============================================================================ -->
  <!-- Creates a .tlog file from the FileWrites items so Clean target works in C++. -->
  <!-- ============================================================================ -->
  <Target Name="_AppendToWriteTlogFile"
          Condition="'$(Language)' == 'C++' and '@(FileWrites)' != ''">
    <WriteLinesToFile
        File="$(TLogLocation)$(ProjectName).write.1u.tlog"
        Lines="^$(ProjectPath);@(FileWrites-&gt;'%(Fullpath)')"
        Encoding="Unicode" />
  </Target>

  <!-- Remember packaging files and directories to clean later.   -->
  <!-- We have to roll our own because targets which handle       -->
  <!-- regular FileWrites items are not considering those outside -->
  <!-- output or intermediate directory.                          -->

  <Target Name="_AppendToPackagingWriteLogs">

    <WriteLinesToFile Condition="'@(PackagingFileWrites)' != ''"
                      File="$(PackagingFileWritesLogPath)"
                      Lines="@(PackagingFileWrites->'%(Fullpath)')"
                      Encoding="Unicode"
                          />

    <WriteLinesToFile Condition="'@(PackagingDirectoryWrites)' != ''"
                      File="$(PackagingDirectoryWritesLogPath)"
                      Lines="@(PackagingDirectoryWrites->'%(Fullpath)')"
                      Encoding="Unicode"
                          />
  </Target>

  <!-- =============================== -->
  <!-- Generating Appx package.        -->
  <!-- Happens when invoked explictly. -->
  <!-- =============================== -->

  <PropertyGroup>
    <_GenerateAppxPackageBaseDependsOn>
      _ComputeAppxPackageOutput;
      _CreateAppxPackage;
      _CreateAppxBundlePlatformSpecificArtifacts;
    </_GenerateAppxPackageBaseDependsOn>

    <_GenerateAppxPackageDependsOn Condition="'$(GenerateAppxPackageOnBuild)' == 'true'">
      $(_GenerateAppxPackageDependsOn);
      $(_GenerateAppxPackageBaseDependsOn);
    </_GenerateAppxPackageDependsOn>

    <_GenerateAppxPackageDependsOn Condition="'$(GenerateAppxPackageOnBuild)' != 'true'">
      $(_GenerateAppxPackageDependsOn);
      _SuppressDeploymentOnlyFeatures;
      Build;
      $(_GenerateAppxPackageBaseDependsOn);
    </_GenerateAppxPackageDependsOn>
  </PropertyGroup>

  <Target Name="_GenerateAppxPackage"
          Condition="'$(AppxPackage)' == 'true'"
          DependsOnTargets="$(_GenerateAppxPackageDependsOn)"
            />

  <PropertyGroup>
    <_CreateAppxPackageDependsOn>
      _ValidateAppxPackage;
      _GenerateAppxPackageFile;
      _GenerateAppxUploadPackageFile;
      _GenerateAppxSymbolPackage;
      _GenerateAppxUploadSymbolPackage;
      _CreateAppStoreContainer;
      _CreateAppStoreContainerForUAP;
      _CreateTestLayout;
      _AddWindowsInstallScriptToTestLayout;
    </_CreateAppxPackageDependsOn>
  </PropertyGroup>

  <!-- Computes Appx package output (file name and directory). -->
  <Target Name="_ComputeAppxPackageOutput">

    <ReadLinesFromFile File="$(_MultipleQualifiersPerDimensionFoundPath)"
                       Condition="'$(AppxBundle)' == 'Auto' and Exists($(_MultipleQualifiersPerDimensionFoundPath))"
                           >
      <Output TaskParameter="Lines" PropertyName="_MultipleQualifiersPerDimensionFound" />
    </ReadLinesFromFile>

    <PropertyGroup Condition="'$(AppxBundle)' == 'Auto'">
      <_MultipleQualifiersPerDimensionFound Condition="'$(_MultipleQualifiersPerDimensionFound)' != 'true'">false</_MultipleQualifiersPerDimensionFound>
    </PropertyGroup>

    <PropertyGroup Condition="'$(TargetPlatformVersion)' == '8.0'">
      <ProduceAppxBundle>false</ProduceAppxBundle>
    </PropertyGroup>

    <PropertyGroup Condition="'$(TargetPlatformVersion)' != '8.0'">
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Auto'">$(_MultipleQualifiersPerDimensionFound)</ProduceAppxBundle>
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Never'">false</ProduceAppxBundle>
      <ProduceAppxBundle Condition="'$(AppxBundle)' == 'Always'">true</ProduceAppxBundle>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageName)' != ''">
      <AppxPackageNameNeutral>$(AppxPackageName)</AppxPackageNameNeutral>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageName)' == ''">
      <AppxPackageNameNeutral>$(ProjectName)_$(AppxManifestIdentityVersion)</AppxPackageNameNeutral>
      <_AppxPackageConfiguration Condition="'$(Configuration)' != 'Release'">_$(Configuration)</_AppxPackageConfiguration>
      <AppxPackageName>$(AppxPackageNameNeutral)_$(Platform)$(_AppxPackageConfiguration)</AppxPackageName>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxStoreContainer)' == '' and '$(ProduceAppxBundle)' == 'false'">
      <AppxStoreContainer>$(AppxPackageDir)$(AppxPackageName)$(AppxStoreContainerExtension)</AppxStoreContainer>
    </PropertyGroup>

    <!-- compute paths for appx -->

    <PropertyGroup Condition="'$(AppxPackageTestDir)' == ''">
      <AppxPackageTestDir Condition="'$(ProduceAppxBundle)' == 'false'">$(AppxPackageDir)$(AppxPackageName)_Test\</AppxPackageTestDir>
      <AppxPackageTestDir Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxPackageDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)_Test\</AppxPackageTestDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageTestExternalPackagesDir)' == ''">
      <AppxPackageTestExternalPackagesDir Condition="'$(ProduceAppxBundle)' == 'false'">$(AppxPackageDir)$(AppxPackageName)_Test\$(ExternalPackagesDir)</AppxPackageTestExternalPackagesDir>
      <AppxPackageTestExternalPackagesDir Condition="'$(ProduceAppxBundle)' == 'true'">$(AppxPackageDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)_Test\$(ExternalPackagesDir)</AppxPackageTestExternalPackagesDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxPackageOutput)' == ''">
      <AppxPackageOutput Condition="'$(AppxPackageEncryptionEnabled)' != 'True'">$(AppxPackageTestDir)$(AppxPackageName)$(AppxPackageExtension)</AppxPackageOutput>
      <AppxPackageOutput Condition="'$(AppxPackageEncryptionEnabled)' == 'True'">$(AppxPackageTestDir)$(AppxPackageName)$(AppxPackageEncryptedExtension)</AppxPackageOutput>
    </PropertyGroup>

    <!-- compute paths for Upload appx & symbols -->

    <PropertyGroup Condition="'$(AppxUploadPackageDir)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageDir Condition="'$(ProduceAppxBundle)' == 'false'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageName)\</AppxUploadPackageDir>
      <AppxUploadPackageDir Condition="'$(ProduceAppxBundle)' == 'true'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)\</AppxUploadPackageDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUploadPackageExternalpackagesDir)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageExternalpackagesDir Condition="'$(ProduceAppxBundle)' == 'false'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageName)\$(ExternalPackagesDir)</AppxUploadPackageExternalpackagesDir>
      <AppxUploadPackageExternalpackagesDir Condition="'$(ProduceAppxBundle)' == 'true'">$(TargetDir)$(AppxUploadPackageArtifactsDir)$(AppxPackageNameNeutral)$(_AppxPackageConfiguration)\$(ExternalPackagesDir)</AppxUploadPackageExternalpackagesDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUploadPackageOutput)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">
      <AppxUploadPackageOutput>$(AppxUploadPackageDir)$(AppxPackageName)$(AppxPackageExtension)</AppxUploadPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxSymbolPackageOutput)' == ''">
      <AppxSymbolPackageOutput>$(AppxPackageTestDir)$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxSymbolPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUploadSymbolPackageOutput)' == ''">
      <AppxUploadSymbolPackageOutput>$(AppxUploadPackageDir)$(AppxPackageName)$(AppxSymbolPackageExtension)</AppxUploadSymbolPackageOutput>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundleDir Condition="'$(AppxBundleDir)' == ''">$(IntermediateOutputPath)$(AppxPackageNameNeutral)$(AppxBundleFolderSuffix)\</AppxBundleDir>
      <AppxBundleDir Condition="!HasTrailingSlash('$(AppxBundleDir)')">$(AppxBundleDir)\</AppxBundleDir>
    </PropertyGroup>

    <PropertyGroup>
      <AppxUploadBundleDir Condition="'$(AppxUploadBundleDir)' == ''">$(IntermediateUploadOutputPath)$(AppxPackageNameNeutral)$(AppxBundleFolderSuffix)\</AppxUploadBundleDir>
      <AppxUploadBundleDir Condition="!HasTrailingSlash('$(AppxUploadBundleDir)')">$(AppxUploadBundleDir)\</AppxUploadBundleDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxMainPackageOutput)' == ''">
      <AppxMainPackageOutput>$(TargetDir)$(AppxPackageName)$(AppxPackageExtension)</AppxMainPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxUploadMainPackageOutput)' == ''">
      <AppxUploadMainPackageOutput>$(TargetDir)Upload\$(AppxPackageName)$(AppxPackageExtension)</AppxUploadMainPackageOutput>
    </PropertyGroup>

    <PropertyGroup Condition="'$(AppxResourcePackOutputBase)' == ''">
      <AppxResourcePackOutputBase>$(TargetDir)$(AppxPackageNameNeutral)</AppxResourcePackOutputBase>
    </PropertyGroup>

  </Target>

  <!-- Extracts hash URI from store association file or provide default. -->
  <!-- Extracts packaging platforms, too.                                -->
  <Target Name="_ExtractStoreAssociationInformation"
          DependsOnTargets="_FindStoreAssociationFile;_ComputeAppxPackageOutput"
          BeforeTargets="_CreateAppxPackage;_CreateMainPackage;_CreateResourcePackages;_CreateBundle;_CalculateAppxBundleProperties">

    <PropertyGroup>
      <_ExtractPlatforms Condition="'$(AppxBundlePlatforms)' == '' and '$(ProduceAppxBundle)' == 'true'">true</_ExtractPlatforms>
      <_ExtractPlatforms Condition="'$(_ExtractPlatforms)' == ''">false</_ExtractPlatforms>
    </PropertyGroup>

    <ExtractStoreAssociationInformation StoreAssociationFile="@(StoreAssociationFile)"
                                        HashUris="@(AppxHashUri)"
                                        ExtractPlatforms="$(_ExtractPlatforms)"
                                        Condition="'@(StoreAssociationFile)' != ''">
      <Output TaskParameter="HashAlgorithmId" PropertyName="AppxHashAlgorithmId" />
      <Output TaskParameter="Platforms" PropertyName="_Platforms" />
    </ExtractStoreAssociationInformation>

    <Warning Condition="('$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' == '' and '$(AppxBundlePlatforms)' == '')
                         or ('$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' != '' and '$(_Platforms)' == '')"
             Text="APPX4001: Build property AppxBundlePlatforms is not explicitly set and is calculated based on currently building architecture. Use 'Create App Package' wizard or edit project file to set it." />

    <Warning Condition="'$(_ExtractPlatforms)' == 'true' and '@(StoreAssociationFile)' != '' and '$(AppxBundlePlatforms)' == '' and '$(_Platforms)' != ''"
             Text="APPX4002: Build property AppxBundlePlatforms is not explicitly set and is calculated based on uploaded packages in the Store for currently building app. Use 'Create App Package' wizard or edit project file to set it." />

    <PropertyGroup Condition="'$(AppxHashAlgorithmId)' == ''">
      <AppxHashAlgorithmId>$(AppxDefaultHashAlgorithmId)</AppxHashAlgorithmId>
    </PropertyGroup>

    <PropertyGroup Condition="'$(_ExtractPlatforms)' == 'true'">
      <AppxBundlePlatforms>$(_Platforms.Replace(';', '|'))</AppxBundlePlatforms>
    </PropertyGroup>

  </Target>

  <!-- Executes pre-upload validation of the appx package. -->
  <Target Name="_ValidateAppxPackage"
          Condition="'$(AppxPackageValidationEnabled)' == 'true'">

    <ValidateAppxPackage
        SourceAppxManifest="@(SourceAppxManifest)"
        AppxManifest="@(FinalAppxManifest)"
        StoreAssociationFile="@(StoreAssociationFile)"
        PackageArchitecture="$(PackageArchitecture)"
        AppxPackagePayload="@(AppxPackagePayload)"
        AppxManifestSchemas="@(AppxManifestSchema)"
        ManifestImageFileNameQueries="@(AppxManifestImageFileNameQuery)"
        ResolvedSDKReferences="@(RecursiveResolvedSDKReference)"
        AllowDebugFrameworkReferencesInManifest="$(AppxPackageAllowDebugFrameworkReferencesInManifest)"
        ProjectDir="$(ProjectDir)"
        MakePriExtensionPath="$(InProcessMakePriExtensionPath)"
        IndexedPayloadFiles="@(IndexedPayloadFiles)"
        OSMinVersion="$(AppxOSMinVersion)"
        ProduceAppxBundle="$(ProduceAppxBundle)"
        IndexedMainPayloadFiles="@(IndexedMainPayloadFiles)"
        MrmSupportLibraryPath="$(MrmSupportLibraryPath)"
        UseResourceIndexerApi="$(AppxUseResourceIndexerApi)"
            />

  </Target>

  <Target Name="_CreateAppxPackage"
          Condition="'$(ProduceAppxBundle)' == 'false'"
          DependsOnTargets="$(_CreateAppxPackageDependsOn)"
            />

  <!-- The following target generates the appx package. -->
  <Target Name="_GenerateAppxPackageFile"
          Inputs="$(MSBuildAllProjects);@(FinalAppxManifest);@(AppxPackagePayload);$(PackageCertificateKeyFile)"
          Outputs="$(AppxPackageOutput)"
          Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or '$(BuildAppxSideloadPackageForUap)' == 'true'"
          DependsOnTargets="_FindAppxContentGroupMap">

    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <AppxPackagePayload Remove="@(AppxPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

    <WriteLinesToFile File="$(AppxPackageFileMap)"
                      Lines="[Files];
                                 @(FinalAppxManifest->'%22%(Identity)%22 %22%(FileName)%(Extension)%22'); 
                                 @(AppxPackagePayload->'%22%(Identity)%22 %22%(TargetPath)%22')"
                      Overwrite="true"
                          />

    <ItemGroup>
      <FileWrites Include="$(AppxPackageFileMap)" />
    </ItemGroup>

    <!-- Package and sign the Test Appx -->

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="%(AppxContentGroupMap.FullPath)"
                  ResourcePack="false"
                  EncryptAppxPackage="$(AppxPackageEncryptionEnabled)"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  FileMap="$(AppxPackageFileMap)"
                  Output="$(AppxPackageOutput)"
                      />

    <ItemGroup>
      <FinalAppxPackageItem Include="$(AppxPackageOutput)" />
    </ItemGroup>

    <ItemGroup>
      <AllBuiltSideloadPackages Include="$(AppxPackageOutput)"/>
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="@(FinalAppxPackageItem)" />
    </ItemGroup>

    <WriteLinesToFile File="$(AppxPackagingInfoFile)"
                      Overwrite="true"
                      Lines="%(FinalAppxPackageItem.FullPath)" />

    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>

    <Message Importance="high" Text="$(MSBuildProjectName) -> %(FinalAppxPackageItem.FullPath)" />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="@(FinalAppxPackageItem)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     ExportCertificate="true">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint"/>
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>

    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(AppxPackagePublicKeyFile)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(MSBuildProjectName) -> $(ResolvedThumbprint)" />

  </Target>

  <!-- The following target generates the appx Upload package. -->
  <Target Name="_GenerateAppxUploadPackageFile"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(FinalAppxUploadManifest);@(AppxUploadPackagePayload);$(PackageCertificateKeyFile)"
          Outputs="$(AppxUploadPackageOutput)"
          DependsOnTargets="_FindAppxContentGroupMap">

    <ItemGroup>
      <AppxUploadPackagePayload Remove="@(AppxUploadPackagePayload)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

    <WriteLinesToFile File="$(AppxUploadPackageFileMap)"
                      Lines="[Files];
                                 @(FinalAppxUploadManifest->'%22%(Identity)%22 %22%(FileName)%(Extension)%22');
                                 @(AppxUploadPackagePayload->'%22%(Identity)%22 %22%(TargetPath)%22')"
                      Overwrite="true"
                          />

    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackageFileMap)" />
    </ItemGroup>

    <!-- Package and sign the Upload Appx -->

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="%(AppxContentGroupMap.FullPath)"
                  ResourcePack="false"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  FileMap="$(AppxUploadPackageFileMap)"
                  Output="$(AppxUploadPackageOutput)"
                      />

    <ItemGroup>
      <FinalAppxUploadPackageItem Include="$(AppxUploadPackageOutput)" />
    </ItemGroup>

    <ItemGroup>
      <AllBuiltUploadPackages Include="$(AppxUploadPackageOutput)"/>
    </ItemGroup>

    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>

    <Message Importance="high" Text="$(MSBuildProjectName) -> %(FinalAppxUploadPackageItem.FullPath)" />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="@(FinalAppxUploadPackageItem)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     ExportCertificate="true">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint"/>
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>

  </Target>

  <!-- The following target creates the appx symbol package. -->
  <Target Name="_GenerateAppxSymbolPackage"
          Condition="'$(AppxSymbolPackageEnabled)' == 'true' and 
                     '@(PDBPayload)' != '' and
                     ('$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or '$(BuildAppxSideloadPackageForUap)' == 'true')"
          Inputs="$(MSBuildAllProjects);@(PDBPayload);@(FinalAppxManifest)"
          Outputs="$(AppxSymbolPackageOutput)">

    <PropertyGroup>
      <StripPrivateSymbols Condition="'$(StripPrivateSymbols)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">false</StripPrivateSymbols>
      <StripPrivateSymbols Condition="'$(StripPrivateSymbols)' == ''">true</StripPrivateSymbols>
      <ReconstituteFastlinkPdbs Condition="'$(StripPrivateSymbols)' == 'false' and
                                           '$(ReconstituteFastlinkPdbs)' == ''">true</ReconstituteFastlinkPdbs>
      <ReconstituteFastlinkPdbs Condition="'$(ReconstituteFastlinkPdbs)' == ''">false</ReconstituteFastlinkPdbs>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' != ''">$(PdbCmfx64ExeFullPath)</MsPdbCmfExeFullpath>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' == ''">$(PdbCmfx86ExeFullPath)</MsPdbCmfExeFullpath>
    </PropertyGroup>

    <GenerateAppxSymbolPackage PdbCopyExeFullPath="$(PdbCopyExeFullPath)"
                               MsPdbCmfExeFullpath="$(MsPdbCmfExeFullpath)"
                               PdbFiles="@(PDBPayload)"
                               ProjectName="$(MSBuildProjectName)"
                               StrippedDirectory="$(AppxSymbolStrippedDir)"
                               StripPrivateSymbols="$(StripPrivateSymbols)"
                               ReconstituteFastlinkPdbs="$(ReconstituteFastlinkPdbs)"
                               AppxSymbolPackageOutput="$(AppxSymbolPackageOutput)">
      <Output TaskParameter="StrippedPdbs" ItemName="StrippedPDBFiles" />
    </GenerateAppxSymbolPackage>

    <ItemGroup>
      <FinalAppxSymbolPackageItem Include="$(AppxSymbolPackageOutput)" />
    </ItemGroup>

    <ItemGroup>
      <PackagingFileWrites Include="@(FinalAppxSymbolPackageItem)" />
      <FileWrites Include="@(StrippedPDBFiles)" />
      <PackagingDirectoryWrites Include="$(AppxSymbolStrippedDir)" />
    </ItemGroup>

    <Message Text="$(MSBuildProjectName) -> $(AppxSymbolPackageOutput)" />

  </Target>

  <!-- The following target creates the Upload appx symbol package. -->
  <Target Name="_GenerateAppxUploadSymbolPackage"
          Condition="'$(AppxSymbolPackageEnabled)' == 'true' and 
                     '@(PDBUploadPayload)' != '' and 
                     '$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(PDBUploadPayload);@(FinalAppxManifest)"
          Outputs="$(AppxUploadSymbolPackageOutput)">

    <PropertyGroup>
      <StripPrivateSymbols Condition="'$(StripPrivateSymbols)' == '' and '$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'">false</StripPrivateSymbols>
      <StripPrivateSymbols Condition="'$(StripPrivateSymbols)' == ''">true</StripPrivateSymbols>
      <ReconstituteFastlinkUploadPdbs Condition="'$(StripPrivateSymbols)' == 'false' and
                                                 '$(ReconstituteFastlinkUploadPdbs)' == ''">true</ReconstituteFastlinkUploadPdbs>
      <ReconstituteFastlinkUploadPdbs Condition="'$(ReconstituteFastlinkUploadPdbs)' == ''">false</ReconstituteFastlinkUploadPdbs>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' != ''">$(PdbCmfx64ExeFullPath)</MsPdbCmfExeFullpath>
      <MsPdbCmfExeFullpath Condition="'$(MSBuildExtensionsPath64)' == ''">$(PdbCmfx86ExeFullPath)</MsPdbCmfExeFullpath>
    </PropertyGroup>

    <GenerateAppxSymbolPackage PdbCopyExeFullPath="$(PdbCopyExeFullPath)"
                               MsPdbCmfExeFullpath="$(MsPdbCmfExeFullpath)"
                               PdbFiles="@(PDBUploadPayload)"
                               ProjectName="$(MSBuildProjectName)"
                               StrippedDirectory="$(AppxUploadSymbolStrippedDir)"
                               StripPrivateSymbols="$(StripPrivateSymbols)"
                               ReconstituteFastlinkPdbs="$(ReconstituteFastlinkUploadPdbs)"
                               AppxSymbolPackageOutput="$(AppxUploadSymbolPackageOutput)">
      <Output TaskParameter="StrippedPdbs" ItemName="StrippedPDBUploadFiles" />
    </GenerateAppxSymbolPackage>

    <ItemGroup>
      <FinalAppxUploadSymbolPackageItem Include="$(AppxUploadSymbolPackageOutput)" />
    </ItemGroup>

    <ItemGroup>
      <PackagingFileWrites Include="@(FinalAppxUploadSymbolPackageItem)" />
      <FileWrites Include="@(StrippedPDBUploadFiles)" />
      <PackagingDirectoryWrites Include="$(AppxUploadSymbolStrippedDir)" />
    </ItemGroup>

    <Message Text="$(MSBuildProjectName) -> $(AppxUploadSymbolPackageOutput)" />

  </Target>

  <!-- Creates a test layout for testing of the appx package. -->
  <Target Name="_CreateTestLayout"
          Condition="'$(AppxTestLayoutEnabled)' == 'true' and
                     ('$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or '$(BuildAppxSideloadPackageForUap)' == 'true')">

    <ItemGroup>
      <_TestLayoutSourceFiles Condition="'%(Architecture)' == 'neutral'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' == 'neutral'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(FileName)%(Extension)')" />
    </ItemGroup>

    <ItemGroup>
      <_TestLayoutSourceFiles Condition="'%(Architecture)' != 'neutral'" Include="@(FrameworkSdkPackage)" />
      <_TestLayoutTargetFiles Condition="'%(Architecture)' != 'neutral'" Include="@(FrameworkSdkPackage->'$(AppxPackageTestDir)Dependencies\%(Architecture)\%(FileName)%(Extension)')" />
    </ItemGroup>

    <Message Importance="low" Text="Test Layout: %(_TestLayoutTargetFiles.FullPath)" />

    <Copy
        UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
        SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
        SourceFiles="@(_TestLayoutSourceFiles)"
        DestinationFiles="@(_TestLayoutTargetFiles)"
            />

    <ItemGroup>
      <PackagingFileWrites Include="@(_TestLayoutTargetFiles)"/>
      <PackagingDirectoryWrites Include="$(AppxPackageTestDir)" />
    </ItemGroup>

  </Target>

  <!-- Find the AppxContentGroupMap path. -->
  <Target Name="_FindAppxContentGroupMap">

    <ItemGroup Condition="'@(AppxContentGroupMap)' == ''">
      <AppxContentGroupMap Include="@(Content)" Condition="'%(Identity)' == 'AppxContentGroupMap.xml'" />
    </ItemGroup>
    
    <!-- Handle the case where the project is a VC Project -->
    <ItemGroup Condition="'@(AppxContentGroupMap)' == ''">
      <AppxContentGroupMap Include="@(Xml)" Condition="'%(Identity)' == 'AppxContentGroupMap.xml'" />
    </ItemGroup>
  </Target>

  <!-- Find the SourceAppxContentGroupMap path. -->
  <Target Name="_FindSourceAppxContentGroupMap">

    <ItemGroup Condition="'@(SourceAppxContentGroupMap)' == ''">
      <SourceAppxContentGroupMap Include="@(AppxSourceContentGroupMap)" Condition="'%(Identity)' == 'SourceAppxContentGroupMap.xml'" />
    </ItemGroup>

    <!-- Handle the case where the project is a JS project -->
    <ItemGroup Condition="'@(SourceAppxContentGroupMap)' == ''">
      <SourceAppxContentGroupMap Include="@(Content)" Condition="'%(Identity)' == 'SourceAppxContentGroupMap.xml'" />
    </ItemGroup>
    
    <!-- Handle the case where the project is a VC Project -->
    <ItemGroup Condition="'@(SourceAppxContentGroupMap)' == ''">
      <SourceAppxContentGroupMap Include="@(Xml)" Condition="'%(Identity)' == 'SourceAppxContentGroupMap.xml'" />
    </ItemGroup>
  </Target>

  <!-- Convert the SourceAppxContentGroupMap file into the target AppxContentGroupMap. -->
  <Target Name="_ConvertAppxContentGroupMap"
          Condition="'$(ConvertSourceAppxContentGroupMap)' == 'true'"
          DependsOnTargets="_FindAppxContentGroupMap;_FindSourceAppxContentGroupMap"
          Outputs="$(AppxMainPackageOutput)">

    <MakeAppxContentGroupMap
                  MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  Output="%(AppxContentGroupMap.FullPath)"
                  SourceAppxContentGroupMap="@(SourceAppxContentGroupMap)"
                  LayoutResFile="$(_LayoutResfilesPath)"
                  ResourcePackFile="$(ProjectPriFullPath)"
                        />

  </Target>


  <!-- Add install script for Windows packages/bundles to the test layout. -->
  <Target Name="_AddWindowsInstallScriptToTestLayout"
          Condition="'$(AppxTestLayoutEnabled)' == 'true' and 
                     '$(_TargetPlatformIsWindowsPhone)' != 'true' and
                     ('$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or '$(BuildAppxSideloadPackageForUap)' == 'true')">

    <ItemGroup>
      <_PowerShellScriptsSource Include="$(AppxMSBuildToolsPath)Add-AppDevPackage.ps1" />
      <_PowerShellScriptsSource Include="$(AppxMSBuildToolsPath)**\Add-AppDevPackage.psd1" />
    </ItemGroup>

    <ItemGroup>
      <_PowerShellScriptsDestination Include="@(_PowerShellScriptsSource->'$(AppxPackageTestDir)%(RecursiveDir)%(FileName)%(Extension)')" />
    </ItemGroup>

    <!--Copy install scripts to app package location.-->
    <Copy
      UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
      SkipUnchangedFiles="true"
      SourceFiles="@(_PowerShellScriptsSource)"
      DestinationFiles="@(_PowerShellScriptsDestination)"
      ContinueOnError="$(ContinueOnError)" />

    <ItemGroup>
      <PackagingFileWrites Include="@(_PowerShellScriptsDestination)" />
    </ItemGroup>

  </Target>

  <!-- Creates .appxupload file containing .appx and optional .appxsym, -->
  <!-- which is used for uploading to Windows App Store.                -->
  <!-- only gets built if the package is for the Legacy App Store          -->
  <Target Name="_CreateAppStoreContainer"
          Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'"
          Inputs="$(MSBuildAllProjects);@(FinalAppxPackageItem);@(FinalAppxSymbolPackageItem)"
          Outputs="$(AppxStoreContainer)">

    <ItemGroup>
      <!-- create temp item just to use .FullPath -->
      <_AppxStoreContainer Include="$(AppxStoreContainer)" />
    </ItemGroup>

    <MakeDir Directories="$(AppxPackageDir)" />

    <CreateAppStoreContainer
        Items="@(FinalAppxPackageItem);@(FinalAppxSymbolPackageItem)"
        ProjectName="$(MSBuildProjectName)"
        OutputPath="%(_AppxStoreContainer.FullPath)"/>

    <ItemGroup>
      <PackagingFileWrites Include="$(AppxStoreContainer)"/>
    </ItemGroup>

  </Target>

  <!-- Creates .appxupload file containing .appx and optional .appxsym, -->
  <!-- which is used for uploading to Windows App Store.                -->
  <!-- only gets built if the package is for the Universal App Store              -->
  <Target Name="_CreateAppStoreContainerForUAP"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
          Inputs="$(MSBuildAllProjects);@(FinalAppxUploadPackageItem);@(FinalAppxUploadSymbolPackageItem)"
          Outputs="$(AppxStoreContainer)">

    <ItemGroup>
      <!-- create temp item just to use .FullPath -->
      <_AppxStoreContainer Include="$(AppxStoreContainer)" />
    </ItemGroup>

    <MakeDir Directories="$(AppxPackageDir)" />

    <CreateAppStoreContainer
        Items="@(FinalAppxUploadPackageItem);@(FinalAppxUploadSymbolPackageItem)"
        ProjectName="$(MSBuildProjectName)"
        OutputPath="%(_AppxStoreContainer.FullPath)"/>

    <ItemGroup>
      <PackagingFileWrites Include="$(AppxStoreContainer)"/>
    </ItemGroup>

  </Target>

  <!-- ================================================== -->
  <!-- Create platform-specific artifacts for app bundle. -->
  <!-- ================================================== -->

  <PropertyGroup>

    <_CreateAppxBundlePlatformSpecificArtifactsDependsOn>
      $(Before_CreateAppxBundlePlatformSpecificArtifacts)

      _GetPackageProperties;

      _CreatePackageLayout_CalculateInputsAndOutputs;
      _CreatePackageLayout;
      _CreatePackageLayout_AddFileWrites;

      _CreateUploadPackageLayout_CalculateInputsAndOutputs;
      _CreateUploadPackageLayout;
      _CreateUploadPackageLayout_AddFileWrites;

      _GetDefaultResourceLanguage;

      _CreatePriConfigXmlForSplitting;
      _CreatePriConfigXmlForSplitting_AddFileWrites;

      _CreateUploadPriConfigXmlForSplitting;
      _CreateUploadPriConfigXmlForSplitting_AddFileWrites;

      _SplitResourcesPri_CalculateInputsAndOutputs;
      _SplitResourcesPri;
      _SplitResourcesPri_AddFileWrites;

      _SplitUploadResourcesPri_CalculateInputsAndOutputs;
      _SplitUploadResourcesPri;
      _SplitUploadResourcesPri_AddFileWrites;

      _ExpandMainPriFile;
      _ValidateAppxPackage;

      _CreatePriConfigXmlForMainPackageFileMap;
      _CreatePriConfigXmlForMainPackageFileMap_AddFileWrites;

      _CreateUploadPriConfigXmlForMainPackageFileMap;
      _CreateUploadPriConfigXmlForMainPackageFileMap_AddFileWrites;

      _CreateMainPackageFileMap_CalculateInputsAndOutputs;
      _CreateMainPackageFileMap;
      _CreateMainPackageFileMap_AddFileWrites;

      _CreateUploadMainPackageFileMap_CalculateInputsAndOutputs;
      _CreateUploadMainPackageFileMap;
      _CreateUploadMainPackageFileMap_AddFileWrites;

      _UpdateMainPackageFileMap;
      _UpdateMainPackageFileMap_AddFileWrites;

      _UpdateUploadMainPackageFileMap;
      _UpdateUploadMainPackageFileMap_AddFileWrites;

      _UpdateAppxManifestForBundle_CalculateInputsAndOutputs;
      _UpdateAppxManifestForBundle;
      _UpdateAppxManifestForBundle_AddFileWrites;

      _UpdateAppxUploadManifestForBundle_CalculateInputsAndOutputs;
      _UpdateAppxUploadManifestForBundle;
      _UpdateAppxUploadManifestForBundle_AddFileWrites;

      _CreateMainPackage;
      _CreateMainPackage_AddFileWrites;

      _CreateMainUploadPackage;
      _CreateMainUploadPackage_AddFileWrites;

      _GenerateAppxSymbolPackage;
      _GenerateAppxUploadSymbolPackage;

      _CreateResourcePackages_CalculateInputsAndOutputs;
      _CreateResourcePackages;
      _CreateResourcePackages_AddFileWrites;

      _CreateUploadResourcePackages_CalculateInputsAndOutputs;
      _CreateUploadResourcePackages;
      _CreateUploadResourcePackages_AddFileWrites;

      _CreatePlatformSpecificArtifactsList;
      _CreatePlatformSpecificUploadArtifactsList;

      _CreateAppxBundleFiles;
      _CreateTestLayout;
      
      $(After_CreateAppxBundlePlatformSpecificArtifacts)
    </_CreateAppxBundlePlatformSpecificArtifactsDependsOn>

  </PropertyGroup>

  <Target Name="_CreateAppxBundlePlatformSpecificArtifacts"
          Condition="'$(ProduceAppxBundle)' == 'true'"
          DependsOnTargets="$(_CreateAppxBundlePlatformSpecificArtifactsDependsOn)"
            />

  <!-- Create the sideload package layout -->
  <Target Name="_CreatePackageLayout_CalculateInputsAndOutputs">

    <ItemGroup>
      <_PackageLayoutFileSource Include="@(AppxPackagePayload)" />
    </ItemGroup>

    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <_PackageLayoutFileSource Remove="@(_PackageLayoutFileSource)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

    <ItemGroup>
      <_PackageLayoutFileSource Remove="$(ProjectPriFullPath)" />
    </ItemGroup>

    <ItemGroup>
      <_PackageLayoutFileTarget Include="@(_PackageLayoutFileSource->'$(AppxLayoutDir)%(TargetPath)')" />
    </ItemGroup>

  </Target>

  <!-- Create the upload package layout -->
  <Target Name="_CreateUploadPackageLayout_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <!-- Make sure the target directory exists as GenerateAppxPackageRecipe won't create it -->
    <MakeDir Directories="$(IntermediateUploadOutputPath)" />

    <ItemGroup>
      <_UploadPackageLayoutFileSource Include="@(AppxUploadPackagePayload)" />
    </ItemGroup>

    <ItemGroup Condition="'$(AppxPackageIncludePrivateSymbols)' != 'true'">
      <_UploadPackageLayoutFileSource Remove="@(_UploadPackageLayoutFileSource)" Condition="'%(Extension)' == '.pdb'" />
    </ItemGroup>

    <ItemGroup>
      <_UploadPackageLayoutFileSource Remove="$(ProjectPriFullPath)" />
      <_UploadPackageLayoutFileSource Remove="$(ProjectPriUploadFullPath)" />
    </ItemGroup>

    <ItemGroup>
      <_UploadPackageLayoutFileTarget Include="@(_UploadPackageLayoutFileSource->'$(AppxUploadLayoutDir)%(TargetPath)')" />
    </ItemGroup>

  </Target>

  <!-- Create the sideload package layout -->
  <Target Name="_CreatePackageLayout">

    <RemoveDir Directories="$(AppxLayoutDir)" />

    <Copy SourceFiles="@(_PackageLayoutFileSource)"
          DestinationFiles="@(_PackageLayoutFileTarget)"
          UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />

    <Message Text="$(ProjectName) -> $(AppxLayoutDir)" />

  </Target>

  <!-- Create the upload package layout -->
  <Target Name="_CreateUploadPackageLayout"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <RemoveDir Directories="$(AppxUploadLayoutDir)" />

    <FilterItemGroup SourceItemGroup="@(_UploadPackageLayoutFileSource)"
                     FilterProperty="NuGetSourceType"
                     FilterValue="Package">
      <Output TaskParameter="FilterMatchItemGroup" ItemName="_PackageLayoutNugetContent" />
      <Output TaskParameter="FilterMismatchItemGroup" ItemName="_PackageLayoutContent" />
    </FilterItemGroup>

    <FilterItemGroup SourceItemGroup="@(_UploadPackageLayoutFileTarget)"
                     FilterProperty="NuGetSourceType"
                     FilterValue="Package">
      <Output TaskParameter="FilterMatchItemGroup" ItemName="_PackageLayoutNugetTarget" />
      <Output TaskParameter="FilterMismatchItemGroup" ItemName="_PackageLayoutTarget" />
    </FilterItemGroup>

    <Copy SourceFiles="@(_PackageLayoutContent)"
          DestinationFiles="@(_PackageLayoutTarget)"
          UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />

    <Copy SourceFiles="@(_PackageLayoutNugetContent)"
          DestinationFiles="@(_PackageLayoutNugetTarget)"
          UseHardlinksIfPossible="$(AppxUseHardlinksForNugetIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)" />

    <Message Text="$(ProjectName) -> $(AppxUploadLayoutDir)" />

  </Target>

  <!-- add sideload file writes -->
  <Target Name="_CreatePackageLayout_AddFileWrites">

    <ItemGroup>
      <FileWrites Include="@(_PackageLayoutFileTarget)" />
      <PackagingDirectoryWrites Include="$(AppxLayoutDir)" />
    </ItemGroup>

  </Target>

  <!-- Add upload file writes -->
  <Target Name="_CreateUploadPackageLayout_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <FileWrites Include="@(_UploadPackageLayoutFileTarget)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadLayoutDir)" />
    </ItemGroup>

  </Target>

  <!-- Create sideload pri config -->
  <Target Name="_CreatePriConfigXmlForSplitting"
          Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)"
          Outputs="$(AppxBundlePriConfigXmlForSplittingFileName)">

    <CreatePriConfigXmlForSplitting
        PriConfigXmlPath="$(AppxBundlePriConfigXmlForSplittingFileName)"
        ResourcesPriFilePath="$(ProjectPriFullPath)"
        PriInitialPath="$(AppxPriInitialPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
        IntermediateExtension="$(AppxIntermediateExtension)"
        PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)"
        PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformResourceVersion)"
        OmitSchemaFromResourcePacks="$(AppxOmitSchemaFromResourcePacks)"
        />

    <Message Text="$(ProjectName) -> $(AppxBundlePriConfigXmlForSplittingFileName)" />

  </Target>

  <!-- Create upload pri config -->
  <Target Name="_CreateUploadPriConfigXmlForSplitting"
          Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)"
          Outputs="$(AppxUploadBundlePriConfigXmlForSplittingFileName)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <CreatePriConfigXmlForSplitting
        PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForSplittingFileName)"
        ResourcesPriFilePath="$(ProjectPriFullPath)"
        PriInitialPath="$(AppxPriInitialPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
        IntermediateExtension="$(AppxIntermediateExtension)"
        PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)"
        PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformResourceVersion)"
            />

    <Message Text="$(ProjectName) -> $(AppxUploadBundlePriConfigXmlForSplittingFileName)" />

  </Target>

  <!-- File writes for the sideload pri config -->
  <Target Name="_CreatePriConfigXmlForSplitting_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundlePriConfigXmlForSplittingFileName)" />
      <FileWrites Include="$(AppxBundlePriConfigXmlForSplittingFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>

  <!-- file writes for the upload pri config -->
  <Target Name="_CreateUploadPriConfigXmlForSplitting_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForSplittingFileName)" />
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForSplittingFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>

  <!-- Prepare to split the sideload resources pri -->
  <Target Name="_SplitResourcesPri_CalculateInputsAndOutputs">

    <ItemGroup>
      <_AppxBundleSplitResourcesGeneratedFiles Remove="@(_AppxBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxBundleSplitResourcesGeneratedFilesListPath))"
                       File="$(AppxBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Prepare to split the upload resources pri -->
  <Target Name="_SplitUploadResourcesPri_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_AppxUploadBundleSplitResourcesGeneratedFiles Remove="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleSplitResourcesGeneratedFilesListPath))"
                       File="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Split the sideload pri -->
  <Target Name="_SplitResourcesPri"
          Inputs="$(MSBuildAllProjects);$(ProjectPriFullPath)"
          Outputs="$(AppxBundleSplitResourcesGeneratedFilesListPath);@(_AppxBundleSplitResourcesGeneratedFiles)">

    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)"
                            MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                            PriConfigXmlPath="$(AppxBundlePriConfigXmlForSplittingFileName)"
                            ProjectPriIndexName="$(ProjectPriIndexName)"
                            MappingFileFormat="AppX"
                            ProjectDirectory="$(AppxLayoutDir)"
                            OutputFileName="$(AppxBundleSplitResourcesPriPath)"
                            GeneratedFilesListPath="$(AppxBundleSplitResourcesGeneratedFilesListPath)"
                            QualifiersPath="$(AppxBundleSplitResourcesQualifiersPath)"
                            IntermediateExtension="$(AppxIntermediateExtension)"
                            AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)"
                            AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                                />

    <ItemGroup>
      <_AppxBundleSplitResourcesGeneratedFiles Remove="@(_AppxBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxBundleSplitResourcesGeneratedFilesListPath))"
                       File="$(AppxBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>

    <Message Text="$(ProjectName) -> %(_AppxBundleSplitResourcesGeneratedFiles.Identity)" />

  </Target>

  <!-- Split the upload pri -->
  <Target Name="_SplitUploadResourcesPri"
          Inputs="$(MSBuildAllProjects);$(ProjectPriFullPath)"
          Outputs="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath);@(_AppxUploadBundleSplitResourcesGeneratedFiles)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)"
                            MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                            PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForSplittingFileName)"
                            ProjectPriIndexName="$(ProjectPriIndexName)"
                            MappingFileFormat="AppX"
                            ProjectDirectory="$(AppxUploadLayoutDir)"
                            OutputFileName="$(AppxUploadBundleSplitResourcesPriPath)"
                            GeneratedFilesListPath="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)"
                            QualifiersPath="$(AppxUploadBundleSplitResourcesQualifiersPath)"
                            IntermediateExtension="$(AppxIntermediateExtension)"
                            AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)"
                            AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                                />

    <ItemGroup>
      <_AppxUploadBundleSplitResourcesGeneratedFiles Remove="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleSplitResourcesGeneratedFilesListPath))"
                       File="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleSplitResourcesGeneratedFiles" />
    </ReadLinesFromFile>

    <Message Text="$(ProjectName) -> %(_AppxUploadBundleSplitResourcesGeneratedFiles.Identity)" />

  </Target>

  <!-- Wrap up splitting the sideload pri -->
  <Target Name="_SplitResourcesPri_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(_AppxBundleSplitResourcesGeneratedFiles)" />
      <FileWrites Include="$(AppxBundleSplitResourcesGeneratedFilesListPath)" />
      <FileWrites Include="$(AppxBundleSplitResourcesQualifiersPath)" />
      <FileWrites Include="$(AppxBundleSplitResourcesQualifiersPath).intermediate" />
    </ItemGroup>
  </Target>

  <!-- Wrap up splitting the upload pri -->
  <Target Name="_SplitUploadResourcesPri_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleSplitResourcesGeneratedFiles)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesGeneratedFilesListPath)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesQualifiersPath)" />
      <FileWrites Include="$(AppxUploadBundleSplitResourcesQualifiersPath).intermediate" />
    </ItemGroup>
  </Target>

  <!-- Create the sideload pri config xml -->
  <Target Name="_CreatePriConfigXmlForMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)"
          Outputs="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)">

    <CreatePriConfigXmlForMainPackageFileMap
        PriConfigXmlPath="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)"
        PriInitialPath="$(AppxPriInitialPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
        IntermediateExtension="$(AppxIntermediateExtension)"
        PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)"
        PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformResourceVersion)"
            />

    <Message Text="$(ProjectName) -> $(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" />

  </Target>

  <!-- Create the upload pri config xml -->
  <Target Name="_CreateUploadPriConfigXmlForMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);$(AppxPriConfigXmlPackagingSnippetPath);$(AppxPriConfigXmlDefaultSnippetPath)"
          Outputs="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <CreatePriConfigXmlForMainPackageFileMap
        PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)"
        PriInitialPath="$(AppxPriInitialPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
        AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
        IntermediateExtension="$(AppxIntermediateExtension)"
        PriConfigXmlPackagingSnippetPath="$(AppxPriConfigXmlPackagingSnippetPath)"
        PriConfigXmlDefaultSnippetPath="$(AppxPriConfigXmlDefaultSnippetPath)"
        TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
        TargetPlatformVersion="$(TargetPlatformResourceVersion)"
            />

    <Message Text="$(ProjectName) -> $(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" />

  </Target>

  <!-- Filewrites for sideload pri config xml -->
  <Target Name="_CreatePriConfigXmlForMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)" />
      <FileWrites Include="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>

  <!-- Filewrites for upload pri config xml -->
  <Target Name="_CreateUploadPriConfigXmlForMainPackageFileMap_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)" />
      <FileWrites Include="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)$(AppxIntermediateExtension)" />
    </ItemGroup>
  </Target>

  <!-- Prepare to create the sideload package file map -->
  <Target Name="_CreateMainPackageFileMap_CalculateInputsAndOutputs">

    <ItemGroup>
      <_AppxBundleMainPackageMapInputs Include="$(AppxLayoutDir)\**\*" />
    </ItemGroup>

    <ItemGroup>
      <_AppxBundleMainPackageMapGeneratedFiles Remove="@(_AppxBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxBundleMainPackageFileMapGeneratedFilesListPath))"
                       File="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Prepare to create the upload package file map -->
  <Target Name="_CreateUploadMainPackageFileMap_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_AppxUploadBundleMainPackageMapInputs Include="$(AppxUploadLayoutDir)\**\*" />
    </ItemGroup>

    <ItemGroup>
      <_AppxUploadBundleMainPackageMapGeneratedFiles Remove="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath))"
                       File="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>

  </Target>

  <!-- Create the sideload package file map -->
  <Target Name="_CreateMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);@(_AppxBundleMainPackageMapInputs)"
          Outputs="$(AppxBundleMainPackageFileMapIntermediatePath)">

    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)"
                            MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                            PriConfigXmlPath="$(AppxBundlePriConfigXmlForMainPackageFileMapFileName)"
                            ProjectPriIndexName="$(ProjectPriIndexName)"
                            MappingFileFormat="AppX"
                            ProjectDirectory="$(AppxLayoutDir)"
                            OutputFileName="$(AppxBundleMainPackageFileMapIntermediatePriPath)"
                            GeneratedFilesListPath="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)"
                            AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)"
                            IntermediateExtension="$(AppxIntermediateExtension)"
                            AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                                />

    <ItemGroup>
      <_AppxBundleMainPackageMapGeneratedFiles Remove="@(_AppxBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxBundleMainPackageFileMapGeneratedFilesListPath))"
                       File="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>

    <Message Text="$(ProjectName) -> %(_AppxBundleMainPackageMapGeneratedFiles.Identity)" />

  </Target>

  <!-- Create the upload package file map -->
  <Target Name="_CreateUploadMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);@(_AppxUploadBundleMainPackageMapInputs)"
          Outputs="$(AppxUploadBundleMainPackageFileMapIntermediatePath)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <GenerateProjectPriFile MakePriExeFullPath="$(MakePriExeFullPath)"
                            MakePriExtensionPath="$(OutOfProcessMakePriExtensionPath)"
                            PriConfigXmlPath="$(AppxUploadBundlePriConfigXmlForMainPackageFileMapFileName)"
                            ProjectPriIndexName="$(ProjectPriIndexName)"
                            MappingFileFormat="AppX"
                            ProjectDirectory="$(AppxUploadLayoutDir)"
                            OutputFileName="$(AppxUploadBundleMainPackageFileMapIntermediatePriPath)"
                            GeneratedFilesListPath="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)"
                            AdditionalMakepriExeParameters="$(AppxGenerateProjectPriFileAdditionalMakepriExeParameters)"
                            IntermediateExtension="$(AppxIntermediateExtension)"
                            AppxBundleAutoResourcePackageQualifiers="$(AppxBundleAutoResourcePackageQualifiers)"
                                />

    <ItemGroup>
      <_AppxUploadBundleMainPackageMapGeneratedFiles Remove="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
    </ItemGroup>

    <ReadLinesFromFile Condition="Exists($(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath))"
                       File="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)">
      <Output TaskParameter="Lines" ItemName="_AppxUploadBundleMainPackageMapGeneratedFiles" />
    </ReadLinesFromFile>

    <Message Text="$(ProjectName) -> %(_AppxUploadBundleMainPackageMapGeneratedFiles.Identity)" />

  </Target>

  <!-- Wrap up creating the sideload file map -->
  <Target Name="_CreateMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="@(_AppxBundleMainPackageMapGeneratedFiles)" />
      <FileWrites Include="$(AppxBundleMainPackageFileMapGeneratedFilesListPath)" />
    </ItemGroup>
  </Target>

  <!-- Wrap up creating the upload file map -->
  <Target Name="_CreateUploadMainPackageFileMap_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleMainPackageMapGeneratedFiles)" />
      <FileWrites Include="$(AppxUploadBundleMainPackageFileMapGeneratedFilesListPath)" />
    </ItemGroup>
  </Target>

  <!-- Update the sideload package file map -->
  <Target Name="_UpdateMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);$(AppxBundleMainPackageFileMapIntermediatePath);$(AppxBundleSplitResourcesPriPath)"
          Outputs="$(AppxBundleMainPackageFileMapPath)">

    <ItemGroup>
      <_AppxBundleSplitResourcesPriPathItem Include="$(AppxBundleSplitResourcesPriPath)" />
    </ItemGroup>

    <UpdateMainPackageFileMap
        Input="$(AppxBundleMainPackageFileMapIntermediatePath)"
        Output="$(AppxBundleMainPackageFileMapPath)"
        SplitResourcesPriPath="%(_AppxBundleSplitResourcesPriPathItem.FullPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
            />

    <Message Text="$(ProjectName) -> $(AppxBundleMainPackageFileMapPath)" />

  </Target>

  <!-- Update the upload package file map -->
  <Target Name="_UpdateUploadMainPackageFileMap"
          Inputs="$(MSBuildAllProjects);$(AppxUploadBundleMainPackageFileMapIntermediatePath);$(AppxUploadBundleSplitResourcesPriPath)"
          Outputs="$(AppxUploadBundleMainPackageFileMapPath)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_AppxUploadBundleSplitResourcesPriPathItem Include="$(AppxUploadBundleSplitResourcesPriPath)" />
    </ItemGroup>

    <UpdateMainPackageFileMap
        Input="$(AppxUploadBundleMainPackageFileMapIntermediatePath)"
        Output="$(AppxUploadBundleMainPackageFileMapPath)"
        SplitResourcesPriPath="%(_AppxUploadBundleSplitResourcesPriPathItem.FullPath)"
        DefaultResourceLanguage="$(DefaultResourceLanguage)"
        DefaultResourceQualifiers="$(AppxDefaultResourceQualifiers)"
            />

    <Message Text="$(ProjectName) -> $(AppxUploadBundleMainPackageFileMapPath)" />

  </Target>

  <!-- Wrap up updating the sideload package file map -->
  <Target Name="_UpdateMainPackageFileMap_AddFileWrites">
    <ItemGroup>
      <FileWrites Include="$(AppxBundleMainPackageFileMapPath)" />
    </ItemGroup>
  </Target>

  <!--Wrap up updating the upload package file map -->
  <Target Name="_UpdateUploadMainPackageFileMap_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadBundleMainPackageFileMapPath)" />
    </ItemGroup>
  </Target>

  <!-- Prepare to update the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle_CalculateInputsAndOutputs">

    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' == 'true'">
      <AppxManifestForBundle Include="@(FinalAppxManifest)" />
    </ItemGroup>

    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' != 'true'">
      <AppxManifestForBundle Include="@(FinalAppxManifest->'%(RootDir)%(Directory)ForBundle\%(Filename)%(Extension)')" />
    </ItemGroup>

  </Target>

  <!-- Prepare to update the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' == 'true'">
      <AppxUploadManifestForBundle Include="@(FinalAppxUploadManifest)" />
    </ItemGroup>

    <ItemGroup Condition="'$(_CustomAppxManifestUsed)' != 'true'">
      <!-- split.pri gets added in a previous step and should not be re-added here -->
      <AppxUploadManifestForBundle Include="@(FinalAppxUploadManifest->'%(RootDir)%(Directory)ForUploadBundle\%(Filename)%(Extension)')" Condition="'%(FinalAppxUploadManifest.TargetPath)' != 'split.pri'" />
    </ItemGroup>

  </Target>

  <!-- Update the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle"
          Inputs="$(MSBuildAllProjects);@(FinalAppxManifest)"
          Outputs="@(AppxManifestForBundle)">

    <MakeDir Directories="@(AppxManifestForBundle->'%(RootDir)%(Directory)')" />

    <UpdateAppxManifestForBundle FinalAppxManifest="@(FinalAppxManifest)"
                                 AppxManifestForBundle="@(AppxManifestForBundle)"
                                 TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                                     />

    <Message Text="$(ProjectName) -> @(AppxManifestForBundle)" />

  </Target>

  <!-- Update the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle"
          Inputs="$(MSBuildAllProjects);@(FinalAppxUploadManifest)"
          Outputs="@(AppxUploadManifestForBundle)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <MakeDir Directories="@(AppxUploadManifestForBundle->'%(RootDir)%(Directory)')" />

    <UpdateAppxManifestForBundle FinalAppxManifest="@(FinalAppxUploadManifest)"
                                 AppxManifestForBundle="@(AppxUploadManifestForBundle)"
                                 TargetPlatformIdentifier="$(TargetPlatformIdentifier)"
                                     />

    <Message Text="$(ProjectName) -> @(AppxUploadManifestForBundle)" />

  </Target>

  <!-- Wrap up updating the sideload manifest -->
  <Target Name="_UpdateAppxManifestForBundle_AddFileWrites">

    <ItemGroup>
      <FileWrites Include="@(AppxManifestForBundle)" />
      <PackagingDirectoryWrites Include="@(AppxManifestForBundle->'%(RootDir)%(Directory)')" />
    </ItemGroup>

  </Target>

  <!-- Wrap up updating the upload manifest -->
  <Target Name="_UpdateAppxUploadManifestForBundle_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <FileWrites Include="@(AppxUploadManifestForBundle)" />
      <PackagingUploadDirectoryWrites Include="@(AppxUploadManifestForBundle->'%(RootDir)%(Directory)')" />
    </ItemGroup>

  </Target>

  <!-- Create the sideload appx -->
  <Target Name="_CreateMainPackage"
          Inputs="$(MSBuildAllProjects);@(AppxManifestForBundle);$(AppxBundleMainPackageFileMapPath);$(PackageCertificateKeyFile)"
          Outputs="$(AppxMainPackageOutput)"
          Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or '$(BuildAppxSideloadPackageForUap)' == 'true'"
          DependsOnTargets="_FindAppxContentGroupMap">

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="%(AppxContentGroupMap.FullPath)"
                  ResourcePack="false"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  AppxManifest="@(AppxManifestForBundle)"
                  FileMap="$(AppxBundleMainPackageFileMapPath)"
                  Output="$(AppxMainPackageOutput)"
                      />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="$(AppxMainPackageOutput)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                         />

    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -> $(AppxMainPackageOutput)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(ProjectName) -> $(AppxMainPackageOutput) (unsigned)" />

  </Target>

  <!-- Create the upload appx -->
  <Target Name="_CreateMainUploadPackage"
          Inputs="$(MSBuildAllProjects);@(AppxUploadManifestForBundle);$(AppxUploadBundleMainPackageFileMapPath);$(PackageCertificateKeyFile)"
          Outputs="$(AppxUploadMainPackageOutput)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
          DependsOnTargets="_FindAppxContentGroupMap">

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="%(AppxContentGroupMap.FullPath)"
                  ResourcePack="false"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  AppxManifest="@(AppxUploadManifestForBundle)"
                  FileMap="$(AppxUploadBundleMainPackageFileMapPath)"
                  Output="$(AppxUploadMainPackageOutput)"
                      />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="$(AppxUploadMainPackageOutput)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                         />

    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -> $(AppxUploadMainPackageOutput)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(ProjectName) -> $(AppxUploadMainPackageOutput) (unsigned)" />

  </Target>

  <!-- Wrap up creating the sideload package -->
  <Target Name="_CreateMainPackage_AddFileWrites"
          Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or '$(BuildAppxSideloadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxMainPackageOutput)" />
      <PackagingDirectoryWrites Include="$(AppxBundleDir)" />
    </ItemGroup>
  </Target>

  <!-- Wrap up creating the upload package -->
  <Target Name="_CreateMainUploadPackage_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <FileWrites Include="$(AppxUploadMainPackageOutput)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadBundleDir)" />
    </ItemGroup>
  </Target>

  <!-- Resource packages are created during the build of the platform which will produce the bundle.               -->
  <!-- There is a work item to validate that assumption which will move resource pack generation to target Bundle. -->
  <!-- 635606: Resource Packs: Validate generated resource packs file maps across architectures                   -->

  <!-- Prep to create the sideload resource packages -->
  <Target Name="_CreateResourcePackages_CalculateInputsAndOutputs"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)'">

    <PropertyGroup>
      <_FileNameToRemove>%(_AppxBundleSplitResourcesPriPathItem.FileName)$(AppxBundleMainPackageFileMapSuffix)</_FileNameToRemove>
    </PropertyGroup>

    <ItemGroup>
      <_AppxBundleResourceFileMapsIntermediate Include="@(_AppxBundleSplitResourcesGeneratedFiles)"
                                               Condition="'%(Extension)' == '.txt' and '%(FileName)' != '$(_FileNameToRemove)'">
        <ResourcePack>$(AppxResourcePackOutputBase)$([System.String]::Copy('%(Filename)').Replace('$(AppxBundleSplitResourcesPriPrefix).','_').Replace('$(AppxBundleMainPackageFileMapSuffix)',''))$(AppxPackageExtension)</ResourcePack>
      </_AppxBundleResourceFileMapsIntermediate>
    </ItemGroup>

    <FilterOutUnusedLanguagesResourceFileMaps FileMaps="@(_AppxBundleResourceFileMapsIntermediate)"
                                              FileNamePrefix="$(AppxBundleSplitResourcesPriPrefix)"
                                              MapSuffix="$(AppxBundleMainPackageFileMapSuffix)"
                                              Languages="@(_ManifestResources->WithMetadataValue('Dimension', 'Language')->'%(Value)')"
                                              Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == 'true'"
                                                  >
      <Output TaskParameter="FilteredFileMaps" ItemName="_AppxBundleResourceFileMaps" />
    </FilterOutUnusedLanguagesResourceFileMaps>

    <ItemGroup Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' != 'true'">
      <_AppxBundleResourceFileMaps Include="@(_AppxBundleResourceFileMapsIntermediate)" />
    </ItemGroup>

    <!-- Find the properties necessary for _CreateResourcePackages MakeAppxPack to work. This was necessary because 
         _AppxBundleResourceFileMaps.Identity and _AppxbundleResourceFileMaps.ResourcePack 
         were not resolving within the MakeAppxPack command.  This only happens when the SourceContentGroupMap.xml
         and ContentGroupMap.xml files are present in the project. -->
    <PropertyGroup>
      <AppxBundleResourceFileMapIdentity>%(_AppxBundleResourceFileMaps.Identity)</AppxBundleResourceFileMapIdentity>
      <AppxBundleResourceFileMapResourcePack>%(_AppxBundleResourceFileMaps.ResourcePack)</AppxBundleResourceFileMapResourcePack>
    </PropertyGroup>
  
  </Target>

  <!-- Prep to create the upload resource packages -->
  <Target Name="_CreateUploadResourcePackages_CalculateInputsAndOutputs"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and 
                     '$(BuildAppxUploadPackageForUap)' == 'true'">

    <PropertyGroup>
      <_FileNameToRemove>%(_AppxBundleSplitResourcesPriPathItem.FileName)$(AppxBundleMainPackageFileMapSuffix)</_FileNameToRemove>
    </PropertyGroup>

    <ItemGroup>
      <_AppxUploadBundleResourceFileMapsIntermediate Include="@(_AppxUploadBundleSplitResourcesGeneratedFiles)"
                                               Condition="'%(Extension)' == '.txt' and '%(FileName)' != '$(_FileNameToRemove)'">
        <ResourcePack>$(AppxUploadResourcePackOutputBase)$([System.String]::Copy('%(Filename)').Replace('$(AppxBundleSplitResourcesPriPrefix).','_').Replace('$(AppxBundleMainPackageFileMapSuffix)',''))$(AppxPackageExtension)</ResourcePack>
      </_AppxUploadBundleResourceFileMapsIntermediate>
    </ItemGroup>

    <FilterOutUnusedLanguagesResourceFileMaps FileMaps="@(_AppxUploadBundleResourceFileMapsIntermediate)"
                                              FileNamePrefix="$(AppxBundleSplitResourcesPriPrefix)"
                                              MapSuffix="$(AppxBundleMainPackageFileMapSuffix)"
                                              Languages="@(_ManifestResources->WithMetadataValue('Dimension', 'Language')->'%(Value)')"
                                              Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' == 'true'"
                                                  >
      <Output TaskParameter="FilteredFileMaps" ItemName="_AppxUploadBundleResourceFileMaps" />
    </FilterOutUnusedLanguagesResourceFileMaps>

    <ItemGroup Condition="'$(AppxFilterOutUnusedLanguagesResourceFileMaps)' != 'true'">
      <_AppxUploadBundleResourceFileMaps Include="@(_AppxUploadBundleResourceFileMapsIntermediate)" />
    </ItemGroup>

  </Target>
  
  <Target Name="_CreateResourcePackages"
          Inputs="@(_AppxBundleResourceFileMaps)"
          Outputs="%(ResourcePack)"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and
                     ('$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or '$(BuildAppxSideloadPackageForUap)' == 'true')"
          DependsOnTargets="_FindAppxContentGroupMap">

    <PropertyGroup>
      <_AppxContentGroupMapFullPath>%(AppxContentGroupMap.FullPath)</_AppxContentGroupMapFullPath>
    </PropertyGroup> 

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="$(_AppxContentGroupMapFullPath)"
                  ResourcePack="true"
                  EncryptAppxPackage="$(AppxPackageEncryptionEnabled)"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  AppxManifest="@(AppxManifestForBundle)"
                  FileMap="%(_AppxBundleResourceFileMaps.Identity)"
                  Output="%(_AppxBundleResourceFileMaps.ResourcePack)"
                  />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="%(_AppxBundleResourceFileMaps.ResourcePack)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     />

    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -> %(_AppxBundleResourceFileMaps.ResourcePack)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(ProjectName) -> %(_AppxBundleResourceFileMaps.ResourcePack) (unsigned)" />

  </Target>

  <Target Name="_CreateUploadResourcePackages"
          Inputs="@(_AppxUploadBundleResourceFileMaps)"
          Outputs="%(ResourcePack)"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and 
                     '$(BuildAppxUploadPackageForUap)' == 'true'"
          DependsOnTargets="_FindAppxContentGroupMap">

    <PropertyGroup>
      <_AppxContentGroupMapFullPath>%(AppxContentGroupMap.FullPath)</_AppxContentGroupMapFullPath>
    </PropertyGroup> 

    <MakeAppxPack MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                  AppxContentGroupMap="$(_AppxContentGroupMapFullPath)"
                  ResourcePack="true"
                  HashAlgorithmId="$(AppxHashAlgorithmId)"
                  ValidateResourcesReferencedByManifest="false"
                  AppxManifest="@(AppxUploadManifestForBundle)"
                  FileMap="%(_AppxUploadBundleResourceFileMaps.Identity)"
                  Output="%(_AppxUploadBundleResourceFileMaps.ResourcePack)"
                      />

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="%(_AppxUploadBundleResourceFileMaps.ResourcePack)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                         />

    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -> %(_AppxUploadBundleResourceFileMaps.ResourcePack)" />
    <Message Importance="high" Condition="'$(AppxPackageSigningEnabled)' != 'true'" Text="$(ProjectName) -> %(_AppxUploadBundleResourceFileMaps.ResourcePack) (unsigned)" />

  </Target>

  <Target Name="_CreateResourcePackages_AddFileWrites"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)'">

    <ItemGroup>
      <FileWrites Include="@(_AppxBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>

  </Target>

  <Target Name="_CreateUploadResourcePackages_AddFileWrites"
          Condition="'$(AppxBundleResourcePacksProducingPlatform)' == '$(PackageArchitecture)' and 
                     '$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <FileWrites Include="@(_AppxUploadBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>

  </Target>

  <!-- Create sideload artifacts list -->
  <Target Name="_CreatePlatformSpecificArtifactsList">

    <MakeDir Directories="$(PlatformSpecificBundleArtifactsListDir)" />

    <ItemGroup>
      <_AppxBundleResourcePack Include="@(_AppxBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>

    <ItemGroup>
      <_PlatformSpecificBundleArtifact Include="MainPackage=$([System.IO.Path]::GetFullPath('$(AppxMainPackageOutput)'))"     Condition="Exists($(AppxMainPackageOutput))" />
      <_PlatformSpecificBundleArtifact Include="SymbolPackage=$([System.IO.Path]::GetFullPath('$(AppxSymbolPackageOutput)'))" Condition="Exists($(AppxSymbolPackageOutput))" />
      <_PlatformSpecificBundleArtifact Include="ResourcePack=%(_AppxBundleResourcePack.FullPath)"                             Condition="'@(_AppxBundleResourcePack)' != ''" />
    </ItemGroup>

    <Delete Files="$(AppxBundlePlatformSpecificArtifactsListPath)" />

    <WriteLinesToFile File="$(AppxBundlePlatformSpecificArtifactsListPath)"
                      Lines="@(_PlatformSpecificBundleArtifact)"
                          />

    <!-- Creating packaging info file for every architecture we are building. -->
    <!-- That way, wizard completion page can know which architectures are    -->
    <!-- included in the bundle.                                              -->

    <PropertyGroup Condition="'$(AppxBundleOutput)' == ''">
      <AppxBundleOutput Condition="'$(AppxPackageEncryptionEnabled)' != 'True'">$(AppxPackageTestDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)$(_AppxPackageConfiguration)$(AppxBundleExtension)</AppxBundleOutput>
      <AppxBundleOutput Condition="'$(AppxPackageEncryptionEnabled)' == 'True'">$(AppxPackageTestDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)$(_AppxPackageConfiguration)$(AppxBundleEncryptedExtension)</AppxBundleOutput>
    </PropertyGroup>

    <WriteLinesToFile File="$(AppxPackagingInfoFile)"
                      Overwrite="true"
                      Lines="$([System.IO.Path]::GetFullPath('$(AppxBundleOutput)'))" />

    <ItemGroup>
      <FileWrites Include="$(AppxPackagingInfoFile)" />
    </ItemGroup>

  </Target>

  <!-- Create upload artifacts list -->
  <Target Name="_CreatePlatformSpecificUploadArtifactsList"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <MakeDir Directories="$(PlatformSpecificUploadBundleArtifactsListDir)" />

    <ItemGroup>
      <_AppxUploadBundleResourcePack Include="@(_AppxUploadBundleResourceFileMaps -> '%(ResourcePack)')" />
    </ItemGroup>

    <ItemGroup>
      <_PlatformSpecificUploadBundleArtifact Include="MainPackage=$([System.IO.Path]::GetFullPath('$(AppxUploadMainPackageOutput)'))" Condition="Exists($(AppxUploadMainPackageOutput))" />
      <_PlatformSpecificUploadBundleArtifact Include="SymbolPackage=$([System.IO.Path]::GetFullPath('$(AppxUploadSymbolPackageOutput)'))"   Condition="Exists($(AppxUploadSymbolPackageOutput))" />
      <_PlatformSpecificUploadBundleArtifact Include="ResourcePack=%(_AppxUploadBundleResourcePack.FullPath)"                         Condition="'@(_AppxUploadBundleResourcePack)' != ''" />
    </ItemGroup>

    <Delete Files="$(AppxBundlePlatformSpecificUploadArtifactsListPath)" />

    <WriteLinesToFile File="$(AppxBundlePlatformSpecificUploadArtifactsListPath)"
                      Lines="@(_PlatformSpecificUploadBundleArtifact)"
                          />

    <!-- Creating packaging info file for every architecture we are building. -->
    <!-- That way, wizard completion page can know which architectures are    -->
    <!-- included in the bundle.                                              -->

    <PropertyGroup Condition="'$(AppxUploadBundleOutput)' == ''">
      <AppxUploadBundleOutput>$(AppxUploadPackageDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)$(_AppxPackageConfiguration)$(AppxBundleExtension)</AppxUploadBundleOutput>
    </PropertyGroup>

    <WriteLinesToFile File="$(AppxUploadPackagingInfoFile)"
                      Overwrite="true"
                      Lines="$([System.IO.Path]::GetFullPath('$(AppxUploadBundleOutput)'))" />

    <ItemGroup>
      <FileWrites Include="$(AppxUploadPackagingInfoFile)" />
    </ItemGroup>

  </Target>

  <!-- ============================= -->
  <!-- Produce the app bundle files. -->
  <!-- ============================= -->

  <PropertyGroup>

    <_CreateAppxBundleFilesDependsOn>
      $(BeforeCreateAppxBundleFiles);

      _GetSdkToolPaths;
      _ValidatePresenceOfAppxManifestItems;
      _GetPackageProperties;

      _GetOtherPlatformsToBundle;
      _ProducePlatformSpecificBundleArtifactsForOtherPlatforms;

      _GetPlatformSpecificBundleArtifacts;

      _CreateBundle_CalculateInputsAndOutputs;
      _CreateBundle_GenerateBundleMappingFile;
      _CreateBundle_CopyExternalPackages;
      _CreateBundle;
      _CreateBundle_AddFileWrites;

      _CreateUploadBundle_CalculateInputsAndOutputs;
      _CreateUploadBundle_GenerateBundleMappingFile;
      _CreateUploadBundle_CopyExternalPackages;
      _CreateUploadBundle;
      _CreateUploadBundle_AddFileWrites;

      _CreateAppStoreBundleContainer_CalculateInputsAndOutputs;
      _CreateAppStoreBundleContainer;
      _CreateAppStoreBundleContainer_AddFileWrites;

      _AddWindowsInstallScriptToTestLayout;

      $(AfterCreateAppxBundleFiles)
    </_CreateAppxBundleFilesDependsOn>

  </PropertyGroup>

  <Target Name="_CreateAppxBundleFiles"
          Condition="('$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)' or '$(GenerateAppxPackageOnBuild)' == 'true') and '$(_SkipBundleCreation)' != 'true'"
          DependsOnTargets="$(_CreateAppxBundleFilesDependsOn)"
            />

  <Target Name="_GetOtherPlatformsToBundle"
          Condition="'$(GenerateAppxPackageOnBuild)' == 'true'">

    <PropertyGroup>
      <_AdjustedPlatform Condition="'$(Platform)' != 'Win32'">$(Platform)</_AdjustedPlatform>
      <_AdjustedPlatform Condition="'$(Platform)' == 'Win32'">x86</_AdjustedPlatform>
    </PropertyGroup>

    <ItemGroup>
      <_OtherPlatformToBundle Condition="'%(Identity)' != '$(_AdjustedPlatform)'" Include="@(AppxBundlePlatformWithAnyCPU)" />
    </ItemGroup>

  </Target>

  <Target Name="_ProducePlatformSpecificBundleArtifactsForOtherPlatforms"
          Condition="'@(_OtherPlatformToBundle)' != ''"
          Inputs="@(_OtherPlatformToBundle)"
          Outputs="%(Identity).AlwaysRun">

    <Message Importance="low" Text="Producing bundle artifacts for platform '%(_OtherPlatformToBundle.Identity)'" />

    <PropertyGroup>
      <_TargetToBuild Condition="'$(_Rebuilding)' == 'true'">Rebuild</_TargetToBuild>
      <_TargetToBuild Condition="'$(_Rebuilding)' != 'true'">Build</_TargetToBuild>
    </PropertyGroup>

    <PropertyGroup Condition="'$(SolutionPath)' == '' or '$(SolutionPath)' == '*Undefined*'">
      <_FileToBuild>$(MSBuildProjectFullPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>false</_ShouldUnsetParentConfigurationAndPlatform>
      <_SolutionConfigurationContentsToUse></_SolutionConfigurationContentsToUse>
    </PropertyGroup>

    <MSBuild Projects="$(SolutionPath)"
             Condition="'$(SolutionPath)' != '' and '$(SolutionPath)' != '*Undefined*'"
             Targets="GetSolutionConfigurationContents"
             Properties="Configuration=$(Configuration);Platform=%(_OtherPlatformToBundle.Identity)"
             ContinueOnError="$(ContinueOnError)">
      <Output TaskParameter="TargetOutputs" PropertyName="_SolutionConfigurationContentsToUse"/>
    </MSBuild>

    <PropertyGroup Condition="'$(SolutionPath)' != '' and '$(SolutionPath)' != '*Undefined*' and '$(IsOptionalProject)' != 'true'">
      <_FileToBuild>$(SolutionPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>true</_ShouldUnsetParentConfigurationAndPlatform>
    </PropertyGroup>

    <PropertyGroup Condition="'$(IsOptionalProject)' == 'true'">
      <_FileToBuild>$(MSBuildProjectFullPath)</_FileToBuild>
      <_ShouldUnsetParentConfigurationAndPlatform>true</_ShouldUnsetParentConfigurationAndPlatform>
      <_SolutionConfigurationContentsToUse></_SolutionConfigurationContentsToUse>
    </PropertyGroup>

    <ItemGroup>
      <_InternalBuildProperties Include="ShouldUnsetParentConfigurationAndPlatform=$(_ShouldUnsetParentConfigurationAndPlatform)" />
      <_InternalBuildProperties Include="CurrentSolutionConfigurationContents=$(_SolutionConfigurationContentsToUse)" />
      <_InternalBuildProperties Include="Configuration=$(Configuration)" />
      <_InternalBuildProperties Include="Platform=%(_OtherPlatformToBundle.Identity)" />
      <_InternalBuildProperties Include="_SkipBundleCreation=true" />
      <_InternalBuildProperties Include="PlatformSpecificBundleArtifactsListDir=$(PlatformSpecificBundleArtifactsListDir)" />
      <_InternalBuildProperties Include="AppxPackageDir=$(AppxPackageDir)" />
    </ItemGroup>

    <PropertyGroup Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == 'true'">
      <InternalBuildOutputPath>$(OutputPath)</InternalBuildOutputPath>
      <InternalBuildOutputPath Condition="!HasTrailingSlash('$(InternalBuildOutputPath)')">$(InternalBuildOutputPath)\</InternalBuildOutputPath>
      <InternalBuildOutputPath>$(InternalBuildOutputPath)%(_OtherPlatformToBundle.Identity)\</InternalBuildOutputPath>
      <InternalBuildOutDir>$(OutDir)</InternalBuildOutDir>
      <InternalBuildOutDir Condition="!HasTrailingSlash('$(InternalBuildOutDir)')">$(InternalBuildOutDir)\</InternalBuildOutDir>
      <InternalBuildOutDir>$(InternalBuildOutDir)%(_OtherPlatformToBundle.Identity)\</InternalBuildOutDir>
    </PropertyGroup>

    <ItemGroup Condition="'$(UseSubFolderForOutputDirDuringMultiPlatformBuild)' == 'true'">
      <_InternalBuildProperties Include="OutputPath=$(InternalBuildOutputPath)" />
      <_InternalBuildProperties Include="OutDir=$(InternalBuildOutDir)" />
    </ItemGroup>

    <!-- Build the package(s) for other platforms that will be included in the bundle. -->
    <MSBuild Projects="$(_FileToBuild)"
             Targets="$(_TargetToBuild)"
             Properties="@(_InternalBuildProperties)"
             ContinueOnError="$(ContinueOnError)"/>

  </Target>

  <Target Name="_GetPlatformSpecificBundleArtifacts">

    <ItemGroup>
      <_PlatformSpecificBundleArtifact Remove="@(_PlatformSpecificBundleArtifact)" />
    </ItemGroup>

    <ItemGroup>
      <_PlatformSpecificUploadBundleArtifact Remove="@(_PlatformSpecificUploadBundleArtifact)" />
    </ItemGroup>

    <ParsePlatformSpecificBundleArtifactsLists Files="$(PlatformSpecificBundleArtifactsListDir)%(AppxBundlePlatform.Identity).txt">
      <Output TaskParameter="Artifacts" ItemName="_PlatformSpecificBundleArtifact" />
    </ParsePlatformSpecificBundleArtifactsLists>

    <ParsePlatformSpecificBundleArtifactsLists Condition="'$(BuildAppxUploadPackageForUap)' == 'true'"
                                               Files="$(PlatformSpecificUploadBundleArtifactsListDir)%(AppxBundlePlatform.Identity).txt">
      <Output TaskParameter="Artifacts" ItemName="_PlatformSpecificUploadBundleArtifact" />
    </ParsePlatformSpecificBundleArtifactsLists>

    <ItemGroup>
      <_MainPackageToBundle   Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'MainPackage'" />
      <_SymbolPackageToBundle Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'SymbolPackage'" />
      <_ResourcePackToBundle  Include="@(_PlatformSpecificBundleArtifact)" Condition="'%(Name)' == 'ResourcePack'" />
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <_MainUploadPackageToBundle Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'MainPackage'"/>
      <_SymbolUploadPackageToBundle Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'SymbolPackage'" />
      <_ResourceUploadPackToBundle  Include="@(_PlatformSpecificUploadBundleArtifact)" Condition="'%(Name)' == 'ResourcePack'" />
    </ItemGroup>

  </Target>

  <!-- Prep to create the sideload bundle -->
  <Target Name="_CreateBundle_CalculateInputsAndOutputs">

    <ItemGroup>
      <_CreateBundleInputs Include="@(_MainPackageToBundle)" />
      <_CreateBundleInputs Include="@(_ResourcePackToBundle)" />
    </ItemGroup>

  </Target>

  <!-- Prep the sideload bundle mapping file -->
  <Target Name="_CreateBundle_GenerateBundleMappingFile"
          Condition="'@(BundleMappingFile)' != ''">

    <GenerateMappingFile Files="@(_CreateBundleInputs)"
                         Externalpackages="@(BundleMappingSideloadExternalPackages)"
                         TargetDirectory="$(AppxMappingFileDir)">
      <Output TaskParameter="MappingFile" PropertyName="AppxBundleMappingFile" />
    </GenerateMappingFile>

  </Target>

  <Target Name="_CreateBundle_CopyExternalPackages"
          Condition="'@(BundleMappingFile)' != ''">

    <RemoveDir Directories="$(AppxPackageTestExternalPackagesDir)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(BundleMappingSideloadExternalPackages)"
          DestinationFolder="$(AppxPackageTestExternalPackagesDir)"
              />

  </Target>

  <!-- Prep to create the upload bundle -->
  <Target Name="_CreateUploadBundle_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <ItemGroup>
      <_CreateUploadBundleInputs Include="@(_MainUploadPackageToBundle)" />
      <_CreateUploadBundleInputs Include="@(_ResourceUploadPackToBundle)" />
    </ItemGroup>

  </Target>

  <!-- Prep the upload bundle mapping file -->
  <Target Name="_CreateUploadBundle_GenerateBundleMappingFile"
          Condition="'@(BundleMappingFile)' != ''">

    <GenerateMappingFile Files="@(_CreateUploadBundleInputs)"
                         Externalpackages="@(BundleMappingUploadExternalPackages)"
                         TargetDirectory="$(AppxUploadMappingFileDir)">
      <Output TaskParameter="MappingFile" PropertyName="AppxUploadBundleMappingFile" />
    </GenerateMappingFile>

  </Target>

  <Target Name="_CreateUploadBundle_CopyExternalPackages"
          Condition="'@(BundleMappingFile)' != ''">

    <RemoveDir Directories="$(AppxUploadPackageExternalpackagesDir)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(BundleMappingUploadExternalPackages)"
          DestinationFolder="$(AppxUploadPackageExternalpackagesDir)"
              />

  </Target>

  <!-- Create the sideload bundle -->
  <Target Name="_CreateBundle"
          Inputs="$(MSBuildAllProjects);@(_CreateBundleInputs);$(PackageCertificateKeyFile)"
          Outputs="$(AppxBundleOutput)"
          Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or '$(BuildAppxSideloadPackageForUap)' == 'true'">

    <VerifyAppxBundlePlatforms PackageArchitecture="$(PackageArchitecture)"
                               AppxBundlePlatforms="@(AppxBundlePlatform)"
                                   />

    <RemoveDir Directories="$(AppxBundleDir)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(_CreateBundleInputs)"
          DestinationFolder="$(AppxBundleDir)"
              />

    <ItemGroup>
      <_AppxBundleContent Include="$(AppxBundleDir)*" />
    </ItemGroup>

    <PropertyGroup Condition="'$(AppxBundleManifestVersion)' == '' and '$(SDKIdentifier)' != ''">
      <AppxBundleManifestVersion>$(AppxManifestIdentityVersion)</AppxBundleManifestVersion>
    </PropertyGroup>

    <Message Text="Adding file '%(_AppxBundleContent.Identity)'" />

    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                    EncryptAppxPackage="$(AppxPackageEncryptionEnabled)"
                    AppxBundleManifestVersion="$(AppxBundleManifestVersion)"
                    BundleDir="$(AppxBundleDir)"
                    Output="$(AppxBundleOutput)"
                    BundleMappingFile="$(AppxBundleMappingFile)"
                        />

    <ItemGroup>
      <AllBuiltSideloadPackages Include="$(AppxBundleOutput)"/>
    </ItemGroup>

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="$(AppxBundleOutput)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     ExportCertificate="true">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint"/>
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>

    <Message Importance="high" Text="$(ProjectName) -> $(AppxBundleOutput)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -> $(AppxPackagePublicKeyFile)" />

  </Target>

  <!-- Create the upload bundle -->
  <Target Name="_CreateUploadBundle"
          Inputs="$(MSBuildAllProjects);@(_CreateUploadBundleInputs);$(PackageCertificateKeyFile)"
          Outputs="$(AppxUploadBundleOutput)"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">

    <VerifyAppxBundlePlatforms PackageArchitecture="$(PackageArchitecture)"
                               AppxBundlePlatforms="@(AppxBundlePlatform)"
                                   />

    <RemoveDir Directories="$(AppxUploadBundleDir)" />

    <Copy UseHardlinksIfPossible="$(AppxUseHardlinksIfPossible)"
          SkipUnchangedFiles="$(AppxSkipUnchangedFiles)"
          SourceFiles="@(_CreateUploadBundleInputs)"
          DestinationFolder="$(AppxUploadBundleDir)"
              />

    <ItemGroup>
      <_AppxUploadBundleContent Include="$(AppxUploadBundleDir)*" />
    </ItemGroup>

    <PropertyGroup Condition="'$(AppxBundleManifestVersion)' == '' and '$(SDKIdentifier)' != ''">
      <AppxBundleManifestVersion>$(AppxManifestIdentityVersion)</AppxBundleManifestVersion>
    </PropertyGroup>

    <Message Text="Adding file '%(_AppxUploadBundleContent.Identity)'" />

    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                    AppxBundleManifestVersion="$(AppxBundleManifestVersion)"
                    BundleDir="$(AppxUploadBundleDir)"
                    Output="$(AppxUploadBundleOutput)"
                    BundleMappingFile="$(AppxUploadBundleMappingFile)"
                        />

    <ItemGroup>
      <AllBuiltUploadPackages Include="$(AppxUploadBundleOutput)"/>
    </ItemGroup>

    <SignAppxPackage Condition="'$(AppxPackageSigningEnabled)' == 'true'"
                     AppxPackageToSign="$(AppxUploadBundleOutput)"
                     CertificateThumbprint="$(PackageCertificateThumbprint)"
                     CertificateFile="$(PackageCertificateKeyFile)"
                     HashAlgorithmId="$(AppxHashAlgorithmId)"
                     EnableSigningChecks="$(EnableSigningChecks)"
                     SignAppxPackageExeFullPath="$(SignAppxPackageExeFullPath)"
                     ExportCertificate="true">
      <Output TaskParameter="ResolvedThumbprint" PropertyName="ResolvedThumbPrint"/>
      <Output TaskParameter="AppxPackagePublicKeyFile" PropertyName="AppxPackagePublicKeyFile" />
    </SignAppxPackage>

    <Message Importance="high" Text="$(ProjectName) -> $(AppxUploadBundleOutput)" />
    <Message Condition="'$(AppxPackageSigningEnabled)' == 'true'" Text="$(ProjectName) -> $(AppxPackagePublicKeyFile)" />

  </Target>

  <!-- wrap up creating the sideload bundle -->
  <Target Name="_CreateBundle_AddFileWrites"
          Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)' or '$(BuildAppxSideloadPackageForUap)' == 'true'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxBundleOutput)" />
      <PackagingDirectoryWrites Include="$(AppxBundleDir)" />
    </ItemGroup>
  </Target>

  <!-- wrap up creating the upload bundle -->
  <Target Name="_CreateUploadBundle_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxUploadBundleOutput)" />
      <PackagingUploadDirectoryWrites Include="$(AppxUploadBundleDir)" />
    </ItemGroup>
  </Target>


  <!--create the final appxupload bundle inputs-->
  <Target Name="_CreateAppStoreBundleContainer_CalculateInputsAndOutputs"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true' or 
                     '$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'">

    <ItemGroup>
      <_CreateAppStoreBundleContainerInputs Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'" Include="$(AppxBundleOutput)" />
      <_CreateAppStoreBundleContainerInputs Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'" Include="$(AppxUploadBundleOutput)" />
      <_CreateAppStoreBundleContainerInputs Condition="'$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'" Include="@(_SymbolPackageToBundle)" />
      <_CreateAppStoreBundleContainerInputs Condition="'$(AppxPackagePipelineVersion)' == '$(UapBuildPipeline)'" Include="@(_SymbolUploadPackageToBundle)" />
    </ItemGroup>

    <PropertyGroup Condition="'$(AppxStoreContainer)' == ''">
      <AppxStoreContainer>$(AppxPackageDir)$(AppxPackageNameNeutral)_$(AppxBundlePlatformsForNaming)_bundle$(_AppxPackageConfiguration)$(AppxStoreContainerExtension)</AppxStoreContainer>
    </PropertyGroup>

  </Target>

  <Target Name="_CreateAppStoreBundleContainer"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true' or 
                     '$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'"
          Inputs="$(MSBuildAllProjects);@(_CreateAppStoreBundleContainerInputs)"
          Outputs="$(AppxStoreContainer)">

    <MakeDir Directories="$(AppxPackageDir)" />

    <CreateAppStoreContainer
        Items="@(_CreateAppStoreBundleContainerInputs)"
        ProjectName="$(MSBuildProjectName)"
        OutputPath="$(AppxStoreContainer)"
            />

  </Target>

  <Target Name="_CreateAppStoreBundleContainer_AddFileWrites"
          Condition="'$(BuildAppxUploadPackageForUap)' == 'true' or 
                     '$(AppxPackagePipelineVersion)' == '$(StandardBuildPipeline)'">
    <ItemGroup>
      <PackagingFileWrites Include="$(AppxStoreContainer)" />
    </ItemGroup>
  </Target>

  <!-- =============================== -->
  <!-- Atomic set creation support.    -->
  <!-- =============================== -->

  <Target Name="_BuildOptionalProjects"
          Condition="'$(BuildOptionalProjects)' == 'true' and
                     '@(BundleMappingFile)' != '' and 
                     '@(_BundleMappingOptionalProjects)' != '' and
                     ('@(AppxBundlePlatforms)' == '' or '$(AppxBundleProducingPlatform)' == '$(PackageArchitecture)')">

    <!--Combine the target to build with GetOptionalProjectOutputs to get back the details we need.-->
    <PropertyGroup>
      <_TargetsToBuild Condition="'$(_Rebuilding)' == 'true'">Rebuild</_TargetsToBuild>
      <_TargetsToBuild Condition="'$(_Rebuilding)' != 'true'">Build</_TargetsToBuild>
      <_TargetsToBuild>$(_TargetsToBuild);GetOptionalProjectOutputs</_TargetsToBuild>
    </PropertyGroup>

    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">false</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">true</_ContinueOnError>
    </PropertyGroup>

    <!--Build the properties list. Split over multiple lines so it's a bit easier to read.-->
    <PropertyGroup>
      <_BuildProperties>Platform=$(Platform);Configuration=$(Configuration)</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);UAPAppxPackageBuildMode=$(UAPAppxPackageBuildMode)</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);AppxPackageIsForStore=$(AppxPackageIsForStore)</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);IncludeOptionalProjectsOutputGroup=true</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);IsOptionalProject=true</_BuildProperties>
      <_BuildProperties>$(_BuildProperties);BuildingInsideVisualStudio=false</_BuildProperties>
      <_BuildProperties Condition="'$(BuildingInsideVisualStudio)' == 'true'">$(_BuildProperties);GenerateAppxPackageOnBuild=$(PackageOptionalProjectsInIdeBuilds)</_BuildProperties>      
      <_BuildProperties Condition="'$(BuildingInsideVisualStudio)' != 'true'">$(_BuildProperties);GenerateAppxPackageOnBuild=$(GenerateAppxPackageOnBuild)</_BuildProperties>
    </PropertyGroup>

    <!--Create the project references for the build.-->    
    <ItemGroup>
      <OptionalProjectBuildReferences Include="@(_BundleMappingOptionalProjects)">
        <Properties>$(_BuildProperties)</Properties>
      </OptionalProjectBuildReferences>
    </ItemGroup>
    
    <!--Build the list of Optional Projects and capture the output from each.-->
    <MSBuild Condition="'$(BuildingInsideVisualStudio)' == 'true'"
             Projects="@(OptionalProjectBuildReferences)"
             BuildInParallel="false"
             ContinueOnError="$(_ContinueOnError)"
             Targets="$(_TargetsToBuild)" >
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectOutputs"/>
    </MSBuild>

    <MSBuild Condition="'$(BuildingInsideVisualStudio)' != 'true'"
             Projects="@(OptionalProjectBuildReferences)"
             BuildInParallel="$(BuildInParallel)"
             ContinueOnError="$(_ContinueOnError)"
             RemoveProperties="AppxPackageDir;OutputPath"
             Targets="$(_TargetsToBuild)" >
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectOutputs"/>
    </MSBuild>

    <!--For Deployment (i.e. debug) builds we just want recipes, manifests, and any external packages.-->
    <ItemGroup>
      <BundleMappingRecipes Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='Recipe'" />
      <BundleMappingExternalPackages Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='Manifest'" />
      <BundleMappingExternalPackages Include="@(_BundleMappingExternalPackages)" />
    </ItemGroup>

    <!--For packaging builds, split sideload and upload into their own groups. Both get the same list of External Packages.-->
    <ItemGroup>
      <BundleMappingSideloadExternalPackages Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='SideloadPackage'" />
      <BundleMappingSideloadExternalPackages Include="@(_BundleMappingExternalPackages)" />
    </ItemGroup>

    <ItemGroup>
      <BundleMappingUploadExternalPackages Include="@(_OptionalProjectOutputs)" Condition="'%(_OptionalProjectOutputs.FileType)'=='UploadPackage'" />
      <BundleMappingUploadExternalPackages Include="@(_BundleMappingExternalPackages)" />
    </ItemGroup>

  </Target>

  <!-- Prep the deployable bundle mapping file -->
  <Target Name="_GenerateBundleMappingFile"
          Condition="'@(BundleMappingFile)' != ''">

    <GenerateMappingFile Files="$(FinalAppxManifestName)"
                         Externalpackages="@(BundleMappingExternalPackages)"
                         TargetDirectory="$(AppxMappingFileDir)">
      <Output TaskParameter="MappingFile" PropertyName="AppxBundleMappingFile" />
    </GenerateMappingFile>

  </Target>

  <Target Name="_GenerateBundleManifest"
          Condition="'@(BundleMappingFile)' != '' and 
                     '@(_BundleMappingOptionalProjects)' != ''">

    <MakeAppxBundle MakeAppxExeFullPath="$(MakeAppxExeFullPath)"
                    Output="$(FinalAppxBundleManifestName)"
                    BundleDir="$(AppxBundleDir)"
                    GenerateBundleManifestOnly="true"
                    BundleMappingFile="$(AppxBundleMappingFile)"
                    />

  </Target>

  <!-- =============================== -->
  <!-- Clean/Rebuild support.          -->
  <!-- =============================== -->

  <!-- Cleans current project and any referenced projects' appx package artifacts. -->
  <Target Name="_CleanAppxPackage"
          Condition="'$(AppxPackage)' == 'true' and '$(GenerateAppxPackageOnBuild)' == 'true'"
          DependsOnTargets="$(_CleanAppxPackageDependsOn)"
          AfterTargets="Clean">

    <ReadLinesFromFile File="$(PackagingDirectoryWritesLogPath)"
                       Condition="Exists($(PackagingDirectoryWritesLogPath))">
      <Output TaskParameter="Lines" ItemName="_DirectoriesToRemove" />
    </ReadLinesFromFile>

    <RemoveDir Directories="@(_DirectoriesToRemove)" ContinueOnError="true" />
    <Delete Files="$(PackagingDirectoryWritesLogPath)" ContinueOnError="true" TreatErrorsAsWarnings="true" />

    <ReadLinesFromFile File="$(PackagingFileWritesLogPath)"
                       Condition="Exists($(PackagingFileWritesLogPath))">
      <Output TaskParameter="Lines" ItemName="_FilesToRemove" />
    </ReadLinesFromFile>

    <Delete Files="@(_FilesToRemove)" ContinueOnError="true" TreatErrorsAsWarnings="true" />
    <Delete Files="$(PackagingFileWritesLogPath)" ContinueOnError="true" TreatErrorsAsWarnings="true" />

  </Target>

  <!-- Rebuild appx package target and entry point. -->
  <Target Name="_RebuildAppxPackage"
          Condition="'$(AppxPackage)' == 'true'"
          DependsOnTargets="$(CleanPackageAction);$(PackageAction)"
            />

  <!-- ========================================== -->
  <!-- Returns Architecture for given Platform.   -->
  <!-- ========================================== -->

  <Target Name="_GetProjectArchitecture"
          Returns="@(ProjectArchitecture)">

    <PropertyGroup>
      <_ProjectArchitectureOutput>Invalid</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'AnyCPU'">neutral</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'x86'">x86</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'Win32'">x86</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'x64'">x64</_ProjectArchitectureOutput>
      <_ProjectArchitectureOutput Condition="'$(Platform)' == 'arm'">arm</_ProjectArchitectureOutput>
    </PropertyGroup>

    <ItemGroup>
      <ProjectArchitecture Include="$(_ProjectArchitectureOutput)" />
    </ItemGroup>

  </Target>

  <!-- ========================================== -->
  <!-- Getting all packaging outputs.             -->
  <!-- Returns items that packaging targets need. -->
  <!-- ========================================== -->

  <PropertyGroup>
    <GetPackagingOutputsDependsOn>
      $(GetPackagingOutputsDependsOn);
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence
    </GetPackagingOutputsDependsOn>
  </PropertyGroup>

  <Target Name="GetPackagingOutputs"
          Returns="@(PackagingOutputs)"
          DependsOnTargets="$(GetPackagingOutputsDependsOn)">

    <CallTarget Targets="BuiltProjectOutputGroup" Condition="'$(IncludeBuiltProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_BuiltProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="%(_BuiltProjectOutputGroupOutput.FinalOutputPath)">
        <TargetPath>%(_BuiltProjectOutputGroupOutput.TargetPath)</TargetPath>
        <OutputGroup>BuiltProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="DebugSymbolsProjectOutputGroup" Condition="'$(IncludeDebugSymbolsProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_DebugSymbolsProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="%(_DebugSymbolsProjectOutputGroupOutput.FinalOutputPath)">
        <OutputGroup>DebugSymbolsProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="DocumentationProjectOutputGroup" Condition="'$(IncludeDocumentationProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_DocumentationProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_DocumentationProjectOutputGroupOutput)">
        <OutputGroup>DocumentationProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SatelliteDllsProjectOutputGroup" Condition="'$(IncludeSatelliteDllsProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SatelliteDllsProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SatelliteDllsProjectOutputGroupOutput)">
        <OutputGroup>SatelliteDllsProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SourceFilesProjectOutputGroup" Condition="'$(IncludeSourceFilesProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SourceFilesProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SourceFilesProjectOutputGroupOutput)">
        <OutputGroup>SourceFilesProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SGenFilesOutputGroup" Condition="'$(IncludeSGenFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SGenFilesOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SGenFilesOutputGroupOutput)">
        <OutputGroup>SGenFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="CopyLocalFilesOutputGroup" Condition="'$(IncludeCopyLocalFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CopyLocalFilesOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CopyLocalFilesOutputGroupOutput)">
        <OutputGroup>CopyLocalFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="ComFilesOutputGroup" Condition="'$(IncludeComFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_ComFilesOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_ComFilesOutputGroupOutput)">
        <OutputGroup>ComFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="CopyWinmdArtifactsOutputGroup" Condition="'$(IncludeCopyWinmdArtifactsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CopyWinmdArtifactsOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CopyWinmdArtifactsOutputGroupOutput)">
        <OutputGroup>CopyWinmdArtifactsOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="SDKRedistOutputGroup" Condition="'$(IncludeSDKRedistOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_SDKRedistOutputGroupOutput"/>
    </CallTarget>

    <ItemGroup>
      <!-- If extension SDK contains both XAML and XBF files, do not package XBF files from SDK -->
      <_SDKRedistRedundantXBF Include="@(_SDKRedistOutputGroupOutput->'%(RootDir)%(Directory)%(Filename).xbf')"
                              Condition="'%(Extension)'=='.xaml'" />
      <_SDKRedistOutputGroupOutput Remove="@(_SDKRedistRedundantXBF)" />
    </ItemGroup>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_SDKRedistOutputGroupOutput)">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Remove="@(RemoveSdkFilesFromAppxPackage)" />
    </ItemGroup>

    <CallTarget Targets="PriFilesOutputGroup" Condition="'$(IncludePriFilesOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_PriFilesOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_PriFilesOutputGroupOutput)">
        <OutputGroup>PriFilesOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="ContentFilesProjectOutputGroup" Condition="'$(IncludeContentFilesProjectOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_ContentFilesProjectOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_ContentFilesProjectOutputGroupOutput)">
        <OutputGroup>ContentFilesProjectOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)\%(_ContentFilesProjectOutputGroupOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <CallTarget Targets="CustomOutputGroupForPackaging" Condition="'$(IncludeCustomOutputGroupForPackaging)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_CustomOutputGroupForPackagingOutput"/>
    </CallTarget>

    <ItemGroup Condition="'$(DisableEmbeddedXbf)' != 'true'">
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(_CustomOutputGroupForPackagingOutput.ReferenceSourceTarget)' == 'ExpandSDKReference'">
        <OutputGroup>SDKRedistOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_CustomOutputGroupForPackagingOutput Remove="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(_CustomOutputGroupForPackagingOutput.ReferenceSourceTarget)' == 'ExpandSDKReference'"/>
    </ItemGroup>

    <ItemGroup>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' != '.xbf'">
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' == '.xbf' AND '$(_SupportXbfAsEmbedFileResources)' != 'true'">
        <OutputGroup>CustomOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
      <_PackagingOutputsUnexpanded Include="@(_CustomOutputGroupForPackagingOutput)" Condition="'%(Extension)' == '.xbf' AND '$(_SupportXbfAsEmbedFileResources)' == 'true'">
        <OutputGroup>EmbedOutputGroupForPackaging</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath Condition="'$(AppxPackage)' != 'true'">$(AppxPriInitialPath)\%(_CustomOutputGroupForPackagingOutput.TargetPath)</TargetPath>
      </_PackagingOutputsUnexpanded>
    </ItemGroup>

    <ExpandPayloadDirectories Inputs="@(_PackagingOutputsUnexpanded)">
      <Output TaskParameter="Expanded" ItemName="_PackagingOutputsExpanded" />
    </ExpandPayloadDirectories>

    <CallTarget Targets="GetResolvedSDKReferences" Condition="'$(IncludeGetResolvedSDKReferences)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_GetResolvedSDKReferencesOutputWithoutMetadata"/>
    </CallTarget>
    <ItemGroup>
      <_GetResolvedSDKReferencesOutput Include="@(_GetResolvedSDKReferencesOutputWithoutMetadata)">
        <OutputGroup>GetResolvedSDKReferences</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_GetResolvedSDKReferencesOutput>
    </ItemGroup>

    <CallTarget Targets="_GetProjectArchitecture">
      <Output TaskParameter="TargetOutputs" ItemName="_ProjectArchitecture" />
    </CallTarget>

    <ItemGroup>
      <_ProjectArchitectureItem Include="@(_ProjectArchitecture)">
        <OutputGroup>_GetProjectArchitecture</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_ProjectArchitectureItem>
    </ItemGroup>

    <ItemGroup>
      <ProjectPriFile Include="$(ProjectPriFullPath)" Condition="'$(IncludeProjectPriFile)' == 'true'">
        <OutputGroup>ProjectPriFile</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriFile>
    </ItemGroup>

    <ItemGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <ProjectPriUploadFile Include="$(ProjectPriUploadFullPath)" Condition="'$(IncludeProjectPriFile)' == 'true'">
        <OutputGroup>ProjectPriUploadFile</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
        <TargetPath>$(ProjectPriFileName)</TargetPath>
      </ProjectPriUploadFile>
    </ItemGroup>

    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">false</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">true</_ContinueOnError>
    </PropertyGroup>

    <MSBuild
      Projects="@(ProjectReferenceWithConfiguration)"
      Targets="GetPackagingOutputs"
      BuildInParallel="$(BuildInParallel)"
      Properties="%(ProjectReferenceWithConfiguration.SetConfiguration); %(ProjectReferenceWithConfiguration.SetPlatform)"
      Condition="'@(ProjectReferenceWithConfiguration)' != ''
                 and '%(ProjectReferenceWithConfiguration.BuildReference)' == 'true' 
                 and '%(ProjectReferenceWithConfiguration.ReferenceOutputAssembly)' == 'true'"
      ContinueOnError="$(_ContinueOnError)">
      <Output TaskParameter="TargetOutputs" ItemName="_PackagingOutputsFromOtherProjects"/>
    </MSBuild>

    <ItemGroup>
      <_PackagingOutputsOutsideLayout Include="@(ProjectPriFile)" />
      <_PackagingOutputsOutsideLayout Include="@(_PackagingOutputsExpanded)" />
      <_PackagingOutputsOutsideLayout Include="@(_GetResolvedSDKReferencesOutput)" />
      <_PackagingOutputsOutsideLayout Include="@(_PackagingOutputsFromOtherProjects)" />
    </ItemGroup>

    <ItemGroup>
      <PathsToExcludeFromLayoutOutputGroup Include="@(_PackagingOutputsOutsideLayout->'%(TargetPath)')" />
      <PathsToExcludeFromLayoutOutputGroup Include="$(AppxManifestTargetPath)" />
      <PathsToExcludeFromLayoutOutputGroup Include="$(DeploymentRecipeTargetPath)" />
    </ItemGroup>

    <ItemGroup>
      <DirsToExcludeFromLayoutOutputGroup Include="$(WinMetadataDir)" />
      <DirsToExcludeFromLayoutOutputGroup Include="$(EntryPointDir)" />
    </ItemGroup>

    <ExpandPayloadDirectories
        Condition="'$(IncludeLayoutFilesInPackage)' == 'true'"
        Inputs="$(LayoutDir)"
        TargetDirsToExclude="@(DirsToExcludeFromLayoutOutputGroup)"
        TargetFilesToExclude="@(PathsToExcludeFromLayoutOutputGroup)"
        >
      <Output TaskParameter="Expanded" ItemName="_PackagingOutputsFromLayout" />
    </ExpandPayloadDirectories>

    <ItemGroup>
      <PackagingOutputs Include="@(_PackagingOutputsFromLayout)">
        <ProjectName>$(ProjectName)</ProjectName>
        <OutputGroup>LayoutOutputGroup</OutputGroup>
      </PackagingOutputs>
      <PackagingOutputs Include="@(_PackagingOutputsOutsideLayout)" />
      <PackagingOutputs Include="@(_ProjectArchitectureItem)" />
    </ItemGroup>

    <Message Text="$(ProjectName) : %(PackagingOutputs.ProjectName).%(PackagingOutputs.OutputGroup) : %(PackagingOutputs.Identity) -> %(PackagingOutputs.TargetPath)" />

  </Target>

  <!-- ========================================== -->
  <!-- Getting all Optional Project outputs.      -->
  <!-- Returns items that packaging targets need. -->
  <!-- ========================================== -->

  <PropertyGroup>
    <GetOptionalProjectOutputsDependsOn>
      $(GetOptionalProjectOutputsDependsOn);
      AssignProjectConfiguration;
      _SplitProjectReferencesByFileExistence
    </GetOptionalProjectOutputsDependsOn>
  </PropertyGroup>

  <Target Name="GetOptionalProjectOutputs"
          Returns="@(OptionalProjectOutputs)"
          DependsOnTargets="$(GetOptionalProjectOutputsDependsOn)">

    <CallTarget Targets="OptionalProjectsOutputGroup" Condition="'$(IncludeOptionalProjectsOutputGroup)' == 'true'">
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectsOutputGroupOutput"/>
    </CallTarget>
    <ItemGroup>
      <_OptionalProjectsOutputs Include="@(_OptionalProjectsOutputGroupOutput)">
        <OutputGroup>OptionalProjectsOutputGroup</OutputGroup>
        <ProjectName>$(ProjectName)</ProjectName>
      </_OptionalProjectsOutputs>
    </ItemGroup>

    <PropertyGroup>
      <_ContinueOnError Condition="'$(BuildingProject)' == 'true'">true</_ContinueOnError>
      <_ContinueOnError Condition="'$(BuildingProject)' != 'true'">false</_ContinueOnError>
    </PropertyGroup>

    <MSBuild
      Projects="@(OptionalProjectBuildReferences)"
      Targets="GetOptionalProjectOutputs"
      BuildInParallel="$(BuildInParallel)"
      Properties="%(OptionalProjectBuildReferences.SetConfiguration); %(OptionalProjectBuildReferences.SetPlatform)"
      ContinueOnError="$(_ContinueOnError)">
      <Output TaskParameter="TargetOutputs" ItemName="_OptionalProjectOutputsFromOtherProjects"/>
    </MSBuild>

    <ItemGroup>
      <_AllOptionalProjectOutputs Include="@(_OptionalProjectsOutputs)"/>
      <_AllOptionalProjectOutputs Include="@(_OptionalProjectOutputsFromOtherProjects)"/>
    </ItemGroup>

    <ItemGroup>
      <OptionalProjectOutputs Include="@(_AllOptionalProjectOutputs)">
        <ProjectName>$(ProjectName)</ProjectName>
        <OutputGroup>OptionalProjectOutputGroup</OutputGroup>
      </OptionalProjectOutputs>
    </ItemGroup>

    <Message Text="$(ProjectName) : %(OptionalProjectOutputs.ProjectName).%(OptionalProjectOutputs.OutputGroup) - %(OptionalProjectOutputs.FileType) : %(OptionalProjectOutputs.Identity) -> %(OptionalProjectOutputs.TargetPath)" />

  </Target>

  <!-- ============================== -->
  <!-- Getting package architecture.  -->
  <!-- ============================== -->

  <PropertyGroup>
    <_GetPackagePropertiesDependsOn>
      $(_GetPackagePropertiesDependsOn);
      _GetProjectArchitecture;
      _GetRecursiveProjectArchitecture;
      _GetPackageArchitecture;
      _GetDefaultResourceLanguage;
      _CalculateAppxBundleProperties;
    </_GetPackagePropertiesDependsOn>
  </PropertyGroup>

  <!-- Gets some package properties. -->
  <Target Name="_GetPackageProperties"
          Condition="'$(AppxGetPackagePropertiesEnabled)' == 'true'"
          DependsOnTargets="$(_GetPackagePropertiesDependsOn)"
            />

  <!-- Extract Project Architecture from the payload -->
  <Target Name="_GetRecursiveProjectArchitecture">

    <ItemGroup>
      <_RecursiveProjectArchitecture Include="@(PackagingOutputs)" Condition="'%(OutputGroup)' == '_GetProjectArchitecture'" />
      <_RecursiveProjectArchitecture Remove="@(_RecursiveProjectArchitecture)" Condition="'%(ProjectName)' == '$(ProjectName)'" />
    </ItemGroup>

  </Target>

  <!-- Gets package architecture. -->
  <Target Name="_GetPackageArchitecture">

    <GetPackageArchitecture
        Platform="$(Platform)"
        ProjectArchitecture="@(ProjectArchitecture)"
        RecursiveProjectArchitecture="@(_RecursiveProjectArchitecture)"
            >
      <Output TaskParameter="PackageArchitecture" PropertyName="PackageArchitecture" />
    </GetPackageArchitecture>

  </Target>

  <!-- Gets default resource language for the package. -->
  <Target Name="_GetDefaultResourceLanguage">

    <GetDefaultResourceLanguage
        DefaultLanguage="$(DefaultLanguage)"
        SourceAppxManifest="@(SourceAppxManifest)"
            >
      <Output TaskParameter="DefaultResourceLanguage" PropertyName="DefaultResourceLanguage" />
    </GetDefaultResourceLanguage>

  </Target>

  <Target Name="_CalculateAppxBundleProperties"
          Condition="'$(AppxBundle)' != 'Never'">

    <PropertyGroup>
      <AppxBundlePlatforms Condition="'$(AppxBundlePlatforms)' == ''">$(PackageArchitecture)</AppxBundlePlatforms>
    </PropertyGroup>

    <GetAppxBundlePlatforms Input="$(AppxBundlePlatforms)">
      <Output TaskParameter="Platforms" ItemName="AppxBundlePlatform" />
      <Output TaskParameter="Last" PropertyName="AppxBundleLastPlatform" />
    </GetAppxBundlePlatforms>

    <ItemGroup>
      <AppxBundlePlatformWithAnyCPU Condition="'%(Identity)' == 'neutral'" Include="@(AppxBundlePlatform -> 'AnyCPU')" />
      <AppxBundlePlatformWithAnyCPU Condition="'%(Identity)' != 'neutral'" Include="@(AppxBundlePlatform)" />
    </ItemGroup>

    <PropertyGroup>
      <_AppxBundlePlatformsForNamingIntermediate>@(AppxBundlePlatformWithAnyCPU)</_AppxBundlePlatformsForNamingIntermediate>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundlePlatformsForNaming>$(_AppxBundlePlatformsForNamingIntermediate.Replace(';','_'))</AppxBundlePlatformsForNaming>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundleProducingPlatform Condition="'$(AppxBundleProducingPlatform)' == ''">$(AppxBundleLastPlatform)</AppxBundleProducingPlatform>
      <AppxBundleResourcePacksProducingPlatform Condition="'$(AppxBundleResourcePacksProducingPlatform)' == ''">$(AppxBundleLastPlatform)</AppxBundleResourcePacksProducingPlatform>
    </PropertyGroup>


    <PropertyGroup Condition="'$(OutDirWasSpecified)' == 'true' 
                              and '$(BuildingInsideVisualStudio)' == 'true'
                              and  $(AppxBundlePlatformsForNaming.Contains('_'))">

      <AppxPackageDir Condition="'$(AppxPackageDirWasSpecified)' != 'true'">$(AppxPackageDirInProjectDir)</AppxPackageDir>
      <PlatformSpecificBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDirWasSpecified)' != 'true'">$(PlatformSpecificBundleArtifactsListDirInProjectDir)</PlatformSpecificBundleArtifactsListDir>
    </PropertyGroup>

    <PropertyGroup Condition="'$(OutDirWasSpecified)' == 'true' 
                              and '$(BuildingInsideVisualStudio)' == 'true'
                              and  $(AppxBundlePlatformsForNaming.Contains('_'))
                              and '$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxUploadPackageDir Condition="'$(AppxPackageDirWasSpecified)' != 'true'">$(AppxUploadPackageDirInProjectDir)</AppxUploadPackageDir>
      <PlatformSpecificUploadBundleArtifactsListDir Condition="'$(PlatformSpecificBundleArtifactsListDirWasSpecified)' != 'true'">$(PlatformSpecificBundleArtifactsListDirInProjectDir)Upload\</PlatformSpecificUploadBundleArtifactsListDir>
    </PropertyGroup>

    <PropertyGroup>
      <AppxBundlePlatformSpecificArtifactsListPath>$(PlatformSpecificBundleArtifactsListDir)$(PackageArchitecture).txt</AppxBundlePlatformSpecificArtifactsListPath>
    </PropertyGroup>

    <PropertyGroup Condition="'$(BuildAppxUploadPackageForUap)' == 'true'">
      <AppxBundlePlatformSpecificUploadArtifactsListPath>$(PlatformSpecificUploadBundleArtifactsListDir)$(PackageArchitecture).txt</AppxBundlePlatformSpecificUploadArtifactsListPath>
    </PropertyGroup>

  </Target>

  <!-- ====================== -->
  <!-- Project output groups. -->
  <!-- ====================== -->

  <!-- Targets that all output groups defined in this targets depends on. -->
  <PropertyGroup>
    <AllOutputGroupsDependsOn>
      $(AllOutputGroupsDependsOn)
      BuildOnlySettings;
      PrepareForBuild;
      AssignTargetPaths;
      ResolveReferences
    </AllOutputGroupsDependsOn>
  </PropertyGroup>

  <!-- ======================================= -->
  <!-- Output group including CopyLocal files. -->
  <!-- ======================================= -->

  <PropertyGroup>
    <CopyLocalFilesOutputGroupDependsOn>
      $(CopyLocalFilesOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </CopyLocalFilesOutputGroupDependsOn>
  </PropertyGroup>

  <Target Name="CopyLocalFilesOutputGroup"
          DependsOnTargets="$(CopyLocalFilesOutputGroupDependsOn)"
          Returns="@(CopyLocalFilesOutputGroupOutput)">

    <ItemGroup>
      <CopyLocalFilesOutputGroupOutput Include="@(ReferenceCopyLocalPaths)"
                                       Condition="'%(ReferenceCopyLocalPaths.Extension)' != '.xml' or '$(AppxCopyLocalFilesOutputGroupIncludeXmlFiles)' == 'true'">
        <TargetPath>%(ReferenceCopyLocalPaths.DestinationSubDirectory)%(ReferenceCopyLocalPaths.Filename)%(ReferenceCopyLocalPaths.Extension)</TargetPath>
      </CopyLocalFilesOutputGroupOutput>
    </ItemGroup>

    <!-- In case of Winmd files, we may not get implementation -->
    <!-- file as separate CopyLocal file (if exist), so we are -->
    <!-- extracting it here.                                   -->
    <ItemGroup>
      <_WinmdWithImplementation
          Include="@(CopyLocalFilesOutputGroupOutput)"
          Condition="'%(CopyLocalFilesOutputGroupOutput.Extension)' == '.winmd' 
                       AND '%(CopyLocalFilesOutputGroupOutput.Filename)' != 'platform'
                       AND '%(CopyLocalFilesOutputGroupOutput.Implementation)' != ''"
                />

      <!-- Determine if any existing copy-local item has already -->
      <!-- satisfied the implementation                          -->
      <_WinmdWithImplementationTargetPath Include="@(_WinmdWithImplementation->'%(DestinationSubDirectory)%(Implementation)')">
        <OriginalItemSpec>%(Identity)</OriginalItemSpec>
      </_WinmdWithImplementationTargetPath>
      <_CopyLocalFilesOutputGroupOutputTargetPath Include="@(CopyLocalFilesOutputGroupOutput->'%(TargetPath)')"/>
      <!-- intersect on targetpath -->
      <_WinmdSatifiedImplementation Include="@(_WinmdWithImplementationTargetPath)"
                                  Condition="'@(_WinmdWithImplementationTargetPath)' == '@(_CopyLocalFilesOutputGroupOutputTargetPath)' AND '%(Identity)' != ''"/>
      <_WinmdWithImplementation Remove="@(_WinmdSatifiedImplementation->'%(OriginalItemSpec)')" />
    </ItemGroup>

    <ItemGroup>
      <CopyLocalFilesOutputGroupOutput Include="%(_WinmdWithImplementation.RootDir)%(_WinmdWithImplementation.Directory)%(_WinmdWithImplementation.Implementation)">
        <TargetPath>%(_WinmdWithImplementation.DestinationSubDirectory)%(_WinmdWithImplementation.Implementation)</TargetPath>
      </CopyLocalFilesOutputGroupOutput>
    </ItemGroup>

  </Target>

  <!-- ======================================= -->
  <!-- Output group including OptionalProjects files. -->
  <!-- ======================================= -->

  <PropertyGroup>
    <OptionalProjectsOutputGroupDependsOn>
      $(OptionalProjectsOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </OptionalProjectsOutputGroupDependsOn>
  </PropertyGroup>

  <Target Name="OptionalProjectsOutputGroup"
          DependsOnTargets="$(OptionalProjectsOutputGroupDependsOn)"
          Returns="@(OptionalProjectsOutputGroupOutput)">

    <ItemGroup>
      <OptionalProjectsOutputGroupOutput Include="@(AllBuiltSideloadPackages)">
        <FileType>SideloadPackage</FileType>
        <TargetPath>%(AllBuiltSideloadPackages.Filename)%(AllBuiltSideloadPackages.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
      <OptionalProjectsOutputGroupOutput Include="@(AllBuiltUploadPackages)">
        <FileType>UploadPackage</FileType>
        <TargetPath>%(AllBuiltUploadPackages.Filename)%(AllBuiltUploadPackages.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
      <OptionalProjectsOutputGroupOutput Include="@(AllGeneratedManifests)">
        <FileType>Manifest</FileType>
        <TargetPath>%(AllGeneratedManifests.Filename)%(AllGeneratedManifests.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
      <OptionalProjectsOutputGroupOutput Include="@(AllGeneratedRecipes)">
        <FileType>Recipe</FileType>
        <TargetPath>%(AllGeneratedRecipes.Filename)%(AllGeneratedRecipes.Extension)</TargetPath>
      </OptionalProjectsOutputGroupOutput>
    </ItemGroup>

  </Target>

  <!-- =========================================== -->
  <!-- Output group including COM reference files. -->
  <!-- =========================================== -->

  <PropertyGroup>
    <ComFilesOutputGroupDependsOn>
      $(ComFilesOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </ComFilesOutputGroupDependsOn>
  </PropertyGroup>

  <Target Name="ComFilesOutputGroup"
          DependsOnTargets="$(ComFilesOutputGroupDependsOn)"
          Returns="@(ComFilesOutputGroupOutputs)">

    <ItemGroup>
      <ComFilesOutputGroupOutputs Include="@(ReferenceComWrappersToCopyLocal)" >
        <TargetPath>%(ReferenceComWrappersToCopyLocal.Filename)%(ReferenceComWrappersToCopyLocal.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
      <ComFilesOutputGroupOutputs Include="@(ResolvedIsolatedComModules)" >
        <TargetPath>%(ResolvedIsolatedComModules.Filename)%(ResolvedIsolatedComModules.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
      <ComFilesOutputGroupOutputs Include="@(NativeReferenceFile)" >
        <TargetPath>%(NativeReferenceFile.Filename)%(NativeReferenceFile.Extension)</TargetPath>
      </ComFilesOutputGroupOutputs>
    </ItemGroup>

  </Target>

  <!-- ============================================ -->
  <!-- Output group including Winmd artifact files. -->
  <!-- ============================================ -->

  <PropertyGroup>
    <CopyWinmdArtifactsOutputGroupDependsOn>
      $(CopyWinmdArtifactsOutputGroupDependsOn);
      $(AllOutputGroupsDependsOn)
    </CopyWinmdArtifactsOutputGroupDependsOn>
  </PropertyGroup>

  <Target
      Name="CopyWinmdArtifactsOutputGroup"
      DependsOnTargets="$(CopyWinmdArtifactsOutputGroupDependsOn)"
      Returns="@(CopyWinmdArtifactsOutputGroupOutputs)">

    <ItemGroup>
      <CopyWinmdArtifactsOutputGroupOutputs Include="@(FinalWinmdExpArtifacts ->'%(FullPath)')">
        <TargetPath>%(FinalWinmdExpArtifacts.DestinationSubDirectory)%(FinalWinmdExpArtifacts.Filename)%(FinalWinmdExpArtifacts.Extension)</TargetPath>
      </CopyWinmdArtifactsOutputGroupOutputs>
    </ItemGroup>

  </Target>

  <!-- ===================== -->
  <!-- Prepare layout target -->
  <!-- ===================== -->

  <PropertyGroup>
    <PrepareLayoutDependsOn>
      $(PrepareLayoutDependsOn);
      BeforePrepareLayout;
      _PrepareLayout;
      AfterPrepareLayout
    </PrepareLayoutDependsOn>
  </PropertyGroup>

  <!-- Prepares layout for debbuging/launching. -->
  <Target
      Name="PrepareLayout"
      Condition="'$(AppxPackage)' == 'true'"
      DependsOnTargets="$(PrepareLayoutDependsOn)" />

  <!-- Implement BeforePrepareLayout to influence final APPX layout recipe content.                          -->
  <!-- Here one can specify these additional items:                                                          -->
  <!-- (TODO: final extensibility items list and names - depending how much InternalPrepareLayout recognize) -->
  <!--                                                                                                       -->
  <!--    @(AppxAdditionalPackageContent)                                                                    -->
  <!--    @(AppxAdditionalSDKDependencies)                                                                   -->
  <!--    @(AppxAdditionalPRI)                                                                               -->
  <!--    @(AppxAdditionalWinmd)                                                                             -->
  <!--                                                                                                       -->
  <Target Name="BeforePrepareLayout" />

  <!-- Internal prepare layout target. -->
  <Target
      Name="_PrepareLayout"
      Inputs="$(MSBuildAllProjects);$(AppxPackageRecipe)"
      Outputs="$(FinalAppxPackageRecipe)">

    <!-- TODO: PRI and Winmd merge steps will be moved here -->

    <Copy UseHardlinksIfPossible="false"
          SourceFiles="$(AppxPackageRecipe)"
          DestinationFiles="$(FinalAppxPackageRecipe)"
              />
  </Target>

  <!-- Implement AfterPrepareLayout if needed to modify layout in more custom way. -->
  <!-- Here one can do arbitraty changes to $(FinalAppxPackageRecipe)              -->
  <Target Name="AfterPrepareLayout" />

</Project>
